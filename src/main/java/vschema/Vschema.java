// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vschema.proto

package vschema;

public final class Vschema {
  private Vschema() {}
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface RoutingRulesOrBuilder extends
      // @@protoc_insertion_point(interface_extends:vschema.RoutingRules)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * rules should ideally be a map. However protos dont't allow
     * repeated fields as elements of a map. So, we use a list
     * instead.
     * </pre>
     *
     * <code>repeated .vschema.RoutingRule rules = 1;</code>
     */
    java.util.List<RoutingRule>
        getRulesList();
    /**
     * <pre>
     * rules should ideally be a map. However protos dont't allow
     * repeated fields as elements of a map. So, we use a list
     * instead.
     * </pre>
     *
     * <code>repeated .vschema.RoutingRule rules = 1;</code>
     */
    RoutingRule getRules(int index);
    /**
     * <pre>
     * rules should ideally be a map. However protos dont't allow
     * repeated fields as elements of a map. So, we use a list
     * instead.
     * </pre>
     *
     * <code>repeated .vschema.RoutingRule rules = 1;</code>
     */
    int getRulesCount();
    /**
     * <pre>
     * rules should ideally be a map. However protos dont't allow
     * repeated fields as elements of a map. So, we use a list
     * instead.
     * </pre>
     *
     * <code>repeated .vschema.RoutingRule rules = 1;</code>
     */
    java.util.List<? extends RoutingRuleOrBuilder>
        getRulesOrBuilderList();
    /**
     * <pre>
     * rules should ideally be a map. However protos dont't allow
     * repeated fields as elements of a map. So, we use a list
     * instead.
     * </pre>
     *
     * <code>repeated .vschema.RoutingRule rules = 1;</code>
     */
    RoutingRuleOrBuilder getRulesOrBuilder(
        int index);
  }
  /**
   * <pre>
   * RoutingRules specify the high level routing rules for the VSchema.
   * </pre>
   *
   * Protobuf type {@code vschema.RoutingRules}
   */
  public  static final class RoutingRules extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:vschema.RoutingRules)
      RoutingRulesOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RoutingRules.newBuilder() to construct.
    private RoutingRules(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RoutingRules() {
      rules_ = java.util.Collections.emptyList();
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private RoutingRules(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                rules_ = new java.util.ArrayList<RoutingRule>();
                mutable_bitField0_ |= 0x00000001;
              }
              rules_.add(
                  input.readMessage(RoutingRule.parser(), extensionRegistry));
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
          rules_ = java.util.Collections.unmodifiableList(rules_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Vschema.internal_static_vschema_RoutingRules_descriptor;
    }

    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Vschema.internal_static_vschema_RoutingRules_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              RoutingRules.class, Builder.class);
    }

    public static final int RULES_FIELD_NUMBER = 1;
    private java.util.List<RoutingRule> rules_;
    /**
     * <pre>
     * rules should ideally be a map. However protos dont't allow
     * repeated fields as elements of a map. So, we use a list
     * instead.
     * </pre>
     *
     * <code>repeated .vschema.RoutingRule rules = 1;</code>
     */
    public java.util.List<RoutingRule> getRulesList() {
      return rules_;
    }
    /**
     * <pre>
     * rules should ideally be a map. However protos dont't allow
     * repeated fields as elements of a map. So, we use a list
     * instead.
     * </pre>
     *
     * <code>repeated .vschema.RoutingRule rules = 1;</code>
     */
    public java.util.List<? extends RoutingRuleOrBuilder>
        getRulesOrBuilderList() {
      return rules_;
    }
    /**
     * <pre>
     * rules should ideally be a map. However protos dont't allow
     * repeated fields as elements of a map. So, we use a list
     * instead.
     * </pre>
     *
     * <code>repeated .vschema.RoutingRule rules = 1;</code>
     */
    public int getRulesCount() {
      return rules_.size();
    }
    /**
     * <pre>
     * rules should ideally be a map. However protos dont't allow
     * repeated fields as elements of a map. So, we use a list
     * instead.
     * </pre>
     *
     * <code>repeated .vschema.RoutingRule rules = 1;</code>
     */
    public RoutingRule getRules(int index) {
      return rules_.get(index);
    }
    /**
     * <pre>
     * rules should ideally be a map. However protos dont't allow
     * repeated fields as elements of a map. So, we use a list
     * instead.
     * </pre>
     *
     * <code>repeated .vschema.RoutingRule rules = 1;</code>
     */
    public RoutingRuleOrBuilder getRulesOrBuilder(
        int index) {
      return rules_.get(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      for (int i = 0; i < rules_.size(); i++) {
        output.writeMessage(1, rules_.get(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (int i = 0; i < rules_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1, rules_.get(i));
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof RoutingRules)) {
        return super.equals(obj);
      }
      RoutingRules other = (RoutingRules) obj;

      boolean result = true;
      result = result && getRulesList()
          .equals(other.getRulesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (getRulesCount() > 0) {
        hash = (37 * hash) + RULES_FIELD_NUMBER;
        hash = (53 * hash) + getRulesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static RoutingRules parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static RoutingRules parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static RoutingRules parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static RoutingRules parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static RoutingRules parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static RoutingRules parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static RoutingRules parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static RoutingRules parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static RoutingRules parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static RoutingRules parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static RoutingRules parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static RoutingRules parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(RoutingRules prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * RoutingRules specify the high level routing rules for the VSchema.
     * </pre>
     *
     * Protobuf type {@code vschema.RoutingRules}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:vschema.RoutingRules)
        RoutingRulesOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Vschema.internal_static_vschema_RoutingRules_descriptor;
      }

      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Vschema.internal_static_vschema_RoutingRules_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                RoutingRules.class, Builder.class);
      }

      // Construct using vschema.Vschema.RoutingRules.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getRulesFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Vschema.internal_static_vschema_RoutingRules_descriptor;
      }

      public RoutingRules getDefaultInstanceForType() {
        return RoutingRules.getDefaultInstance();
      }

      public RoutingRules build() {
        RoutingRules result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public RoutingRules buildPartial() {
        RoutingRules result = new RoutingRules(this);
        int from_bitField0_ = bitField0_;
        if (rulesBuilder_ == null) {
          if (((bitField0_ & 0x00000001) == 0x00000001)) {
            rules_ = java.util.Collections.unmodifiableList(rules_);
            bitField0_ = (bitField0_ & ~0x00000001);
          }
          result.rules_ = rules_;
        } else {
          result.rules_ = rulesBuilder_.build();
        }
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof RoutingRules) {
          return mergeFrom((RoutingRules)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(RoutingRules other) {
        if (other == RoutingRules.getDefaultInstance()) return this;
        if (rulesBuilder_ == null) {
          if (!other.rules_.isEmpty()) {
            if (rules_.isEmpty()) {
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000001);
            } else {
              ensureRulesIsMutable();
              rules_.addAll(other.rules_);
            }
            onChanged();
          }
        } else {
          if (!other.rules_.isEmpty()) {
            if (rulesBuilder_.isEmpty()) {
              rulesBuilder_.dispose();
              rulesBuilder_ = null;
              rules_ = other.rules_;
              bitField0_ = (bitField0_ & ~0x00000001);
              rulesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getRulesFieldBuilder() : null;
            } else {
              rulesBuilder_.addAllMessages(other.rules_);
            }
          }
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        RoutingRules parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (RoutingRules) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private java.util.List<RoutingRule> rules_ =
        java.util.Collections.emptyList();
      private void ensureRulesIsMutable() {
        if (!((bitField0_ & 0x00000001) == 0x00000001)) {
          rules_ = new java.util.ArrayList<RoutingRule>(rules_);
          bitField0_ |= 0x00000001;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          RoutingRule, RoutingRule.Builder, RoutingRuleOrBuilder> rulesBuilder_;

      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public java.util.List<RoutingRule> getRulesList() {
        if (rulesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(rules_);
        } else {
          return rulesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public int getRulesCount() {
        if (rulesBuilder_ == null) {
          return rules_.size();
        } else {
          return rulesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public RoutingRule getRules(int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);
        } else {
          return rulesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public Builder setRules(
          int index, RoutingRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.set(index, value);
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public Builder setRules(
          int index, RoutingRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.set(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public Builder addRules(RoutingRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public Builder addRules(
          int index, RoutingRule value) {
        if (rulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureRulesIsMutable();
          rules_.add(index, value);
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public Builder addRules(
          RoutingRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public Builder addRules(
          int index, RoutingRule.Builder builderForValue) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.add(index, builderForValue.build());
          onChanged();
        } else {
          rulesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public Builder addAllRules(
          Iterable<? extends RoutingRule> values) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, rules_);
          onChanged();
        } else {
          rulesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public Builder clearRules() {
        if (rulesBuilder_ == null) {
          rules_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000001);
          onChanged();
        } else {
          rulesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public Builder removeRules(int index) {
        if (rulesBuilder_ == null) {
          ensureRulesIsMutable();
          rules_.remove(index);
          onChanged();
        } else {
          rulesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public RoutingRule.Builder getRulesBuilder(
          int index) {
        return getRulesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public RoutingRuleOrBuilder getRulesOrBuilder(
          int index) {
        if (rulesBuilder_ == null) {
          return rules_.get(index);  } else {
          return rulesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public java.util.List<? extends RoutingRuleOrBuilder>
           getRulesOrBuilderList() {
        if (rulesBuilder_ != null) {
          return rulesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(rules_);
        }
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public RoutingRule.Builder addRulesBuilder() {
        return getRulesFieldBuilder().addBuilder(
            RoutingRule.getDefaultInstance());
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public RoutingRule.Builder addRulesBuilder(
          int index) {
        return getRulesFieldBuilder().addBuilder(
            index, RoutingRule.getDefaultInstance());
      }
      /**
       * <pre>
       * rules should ideally be a map. However protos dont't allow
       * repeated fields as elements of a map. So, we use a list
       * instead.
       * </pre>
       *
       * <code>repeated .vschema.RoutingRule rules = 1;</code>
       */
      public java.util.List<RoutingRule.Builder>
           getRulesBuilderList() {
        return getRulesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          RoutingRule, RoutingRule.Builder, RoutingRuleOrBuilder>
          getRulesFieldBuilder() {
        if (rulesBuilder_ == null) {
          rulesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              RoutingRule, RoutingRule.Builder, RoutingRuleOrBuilder>(
                  rules_,
                  ((bitField0_ & 0x00000001) == 0x00000001),
                  getParentForChildren(),
                  isClean());
          rules_ = null;
        }
        return rulesBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:vschema.RoutingRules)
    }

    // @@protoc_insertion_point(class_scope:vschema.RoutingRules)
    private static final RoutingRules DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new RoutingRules();
    }

    public static RoutingRules getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RoutingRules>
        PARSER = new com.google.protobuf.AbstractParser<RoutingRules>() {
      public RoutingRules parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new RoutingRules(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<RoutingRules> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<RoutingRules> getParserForType() {
      return PARSER;
    }

    public RoutingRules getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface RoutingRuleOrBuilder extends
      // @@protoc_insertion_point(interface_extends:vschema.RoutingRule)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>string from_table = 1;</code>
     */
    String getFromTable();
    /**
     * <code>string from_table = 1;</code>
     */
    com.google.protobuf.ByteString
        getFromTableBytes();

    /**
     * <code>repeated string to_tables = 2;</code>
     */
    java.util.List<String>
        getToTablesList();
    /**
     * <code>repeated string to_tables = 2;</code>
     */
    int getToTablesCount();
    /**
     * <code>repeated string to_tables = 2;</code>
     */
    String getToTables(int index);
    /**
     * <code>repeated string to_tables = 2;</code>
     */
    com.google.protobuf.ByteString
        getToTablesBytes(int index);
  }
  /**
   * <pre>
   * RoutingRule specifies a routing rule.
   * </pre>
   *
   * Protobuf type {@code vschema.RoutingRule}
   */
  public  static final class RoutingRule extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:vschema.RoutingRule)
      RoutingRuleOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use RoutingRule.newBuilder() to construct.
    private RoutingRule(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private RoutingRule() {
      fromTable_ = "";
      toTables_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private RoutingRule(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              String s = input.readStringRequireUtf8();

              fromTable_ = s;
              break;
            }
            case 18: {
              String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                toTables_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000002;
              }
              toTables_.add(s);
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          toTables_ = toTables_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Vschema.internal_static_vschema_RoutingRule_descriptor;
    }

    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Vschema.internal_static_vschema_RoutingRule_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              RoutingRule.class, Builder.class);
    }

    private int bitField0_;
    public static final int FROM_TABLE_FIELD_NUMBER = 1;
    private volatile Object fromTable_;
    /**
     * <code>string from_table = 1;</code>
     */
    public String getFromTable() {
      Object ref = fromTable_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        fromTable_ = s;
        return s;
      }
    }
    /**
     * <code>string from_table = 1;</code>
     */
    public com.google.protobuf.ByteString
        getFromTableBytes() {
      Object ref = fromTable_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        fromTable_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TO_TABLES_FIELD_NUMBER = 2;
    private com.google.protobuf.LazyStringList toTables_;
    /**
     * <code>repeated string to_tables = 2;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getToTablesList() {
      return toTables_;
    }
    /**
     * <code>repeated string to_tables = 2;</code>
     */
    public int getToTablesCount() {
      return toTables_.size();
    }
    /**
     * <code>repeated string to_tables = 2;</code>
     */
    public String getToTables(int index) {
      return toTables_.get(index);
    }
    /**
     * <code>repeated string to_tables = 2;</code>
     */
    public com.google.protobuf.ByteString
        getToTablesBytes(int index) {
      return toTables_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getFromTableBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, fromTable_);
      }
      for (int i = 0; i < toTables_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, toTables_.getRaw(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getFromTableBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, fromTable_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < toTables_.size(); i++) {
          dataSize += computeStringSizeNoTag(toTables_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getToTablesList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof RoutingRule)) {
        return super.equals(obj);
      }
      RoutingRule other = (RoutingRule) obj;

      boolean result = true;
      result = result && getFromTable()
          .equals(other.getFromTable());
      result = result && getToTablesList()
          .equals(other.getToTablesList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + FROM_TABLE_FIELD_NUMBER;
      hash = (53 * hash) + getFromTable().hashCode();
      if (getToTablesCount() > 0) {
        hash = (37 * hash) + TO_TABLES_FIELD_NUMBER;
        hash = (53 * hash) + getToTablesList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static RoutingRule parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static RoutingRule parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static RoutingRule parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static RoutingRule parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static RoutingRule parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static RoutingRule parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static RoutingRule parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static RoutingRule parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static RoutingRule parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static RoutingRule parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static RoutingRule parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static RoutingRule parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(RoutingRule prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * RoutingRule specifies a routing rule.
     * </pre>
     *
     * Protobuf type {@code vschema.RoutingRule}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:vschema.RoutingRule)
        RoutingRuleOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Vschema.internal_static_vschema_RoutingRule_descriptor;
      }

      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Vschema.internal_static_vschema_RoutingRule_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                RoutingRule.class, Builder.class);
      }

      // Construct using vschema.Vschema.RoutingRule.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        fromTable_ = "";

        toTables_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Vschema.internal_static_vschema_RoutingRule_descriptor;
      }

      public RoutingRule getDefaultInstanceForType() {
        return RoutingRule.getDefaultInstance();
      }

      public RoutingRule build() {
        RoutingRule result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public RoutingRule buildPartial() {
        RoutingRule result = new RoutingRule(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.fromTable_ = fromTable_;
        if (((bitField0_ & 0x00000002) == 0x00000002)) {
          toTables_ = toTables_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000002);
        }
        result.toTables_ = toTables_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof RoutingRule) {
          return mergeFrom((RoutingRule)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(RoutingRule other) {
        if (other == RoutingRule.getDefaultInstance()) return this;
        if (!other.getFromTable().isEmpty()) {
          fromTable_ = other.fromTable_;
          onChanged();
        }
        if (!other.toTables_.isEmpty()) {
          if (toTables_.isEmpty()) {
            toTables_ = other.toTables_;
            bitField0_ = (bitField0_ & ~0x00000002);
          } else {
            ensureToTablesIsMutable();
            toTables_.addAll(other.toTables_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        RoutingRule parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (RoutingRule) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private Object fromTable_ = "";
      /**
       * <code>string from_table = 1;</code>
       */
      public String getFromTable() {
        Object ref = fromTable_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          fromTable_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <code>string from_table = 1;</code>
       */
      public com.google.protobuf.ByteString
          getFromTableBytes() {
        Object ref = fromTable_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          fromTable_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string from_table = 1;</code>
       */
      public Builder setFromTable(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        fromTable_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string from_table = 1;</code>
       */
      public Builder clearFromTable() {
        
        fromTable_ = getDefaultInstance().getFromTable();
        onChanged();
        return this;
      }
      /**
       * <code>string from_table = 1;</code>
       */
      public Builder setFromTableBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        fromTable_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList toTables_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureToTablesIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          toTables_ = new com.google.protobuf.LazyStringArrayList(toTables_);
          bitField0_ |= 0x00000002;
         }
      }
      /**
       * <code>repeated string to_tables = 2;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getToTablesList() {
        return toTables_.getUnmodifiableView();
      }
      /**
       * <code>repeated string to_tables = 2;</code>
       */
      public int getToTablesCount() {
        return toTables_.size();
      }
      /**
       * <code>repeated string to_tables = 2;</code>
       */
      public String getToTables(int index) {
        return toTables_.get(index);
      }
      /**
       * <code>repeated string to_tables = 2;</code>
       */
      public com.google.protobuf.ByteString
          getToTablesBytes(int index) {
        return toTables_.getByteString(index);
      }
      /**
       * <code>repeated string to_tables = 2;</code>
       */
      public Builder setToTables(
          int index, String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureToTablesIsMutable();
        toTables_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string to_tables = 2;</code>
       */
      public Builder addToTables(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureToTablesIsMutable();
        toTables_.add(value);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string to_tables = 2;</code>
       */
      public Builder addAllToTables(
          Iterable<String> values) {
        ensureToTablesIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, toTables_);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string to_tables = 2;</code>
       */
      public Builder clearToTables() {
        toTables_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000002);
        onChanged();
        return this;
      }
      /**
       * <code>repeated string to_tables = 2;</code>
       */
      public Builder addToTablesBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureToTablesIsMutable();
        toTables_.add(value);
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:vschema.RoutingRule)
    }

    // @@protoc_insertion_point(class_scope:vschema.RoutingRule)
    private static final RoutingRule DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new RoutingRule();
    }

    public static RoutingRule getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<RoutingRule>
        PARSER = new com.google.protobuf.AbstractParser<RoutingRule>() {
      public RoutingRule parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new RoutingRule(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<RoutingRule> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<RoutingRule> getParserForType() {
      return PARSER;
    }

    public RoutingRule getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface KeyspaceOrBuilder extends
      // @@protoc_insertion_point(interface_extends:vschema.Keyspace)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * If sharded is false, vindexes and tables are ignored.
     * </pre>
     *
     * <code>bool sharded = 1;</code>
     */
    boolean getSharded();

    /**
     * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
     */
    int getVindexesCount();
    /**
     * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
     */
    boolean containsVindexes(
        String key);
    /**
     * Use {@link #getVindexesMap()} instead.
     */
    @Deprecated
    java.util.Map<String, Vindex>
    getVindexes();
    /**
     * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
     */
    java.util.Map<String, Vindex>
    getVindexesMap();
    /**
     * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
     */

    Vindex getVindexesOrDefault(
        String key,
        Vindex defaultValue);
    /**
     * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
     */

    Vindex getVindexesOrThrow(
        String key);

    /**
     * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
     */
    int getTablesCount();
    /**
     * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
     */
    boolean containsTables(
        String key);
    /**
     * Use {@link #getTablesMap()} instead.
     */
    @Deprecated
    java.util.Map<String, Table>
    getTables();
    /**
     * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
     */
    java.util.Map<String, Table>
    getTablesMap();
    /**
     * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
     */

    Table getTablesOrDefault(
        String key,
        Table defaultValue);
    /**
     * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
     */

    Table getTablesOrThrow(
        String key);

    /**
     * <pre>
     * If require_explicit_routing is true, vindexes and tables are not added to global routing
     * </pre>
     *
     * <code>bool require_explicit_routing = 4;</code>
     */
    boolean getRequireExplicitRouting();
  }
  /**
   * <pre>
   * Keyspace is the vschema for a keyspace.
   * </pre>
   *
   * Protobuf type {@code vschema.Keyspace}
   */
  public  static final class Keyspace extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:vschema.Keyspace)
      KeyspaceOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Keyspace.newBuilder() to construct.
    private Keyspace(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Keyspace() {
      sharded_ = false;
      requireExplicitRouting_ = false;
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Keyspace(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 8: {

              sharded_ = input.readBool();
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                vindexes_ = com.google.protobuf.MapField.newMapField(
                    VindexesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<String, Vindex>
              vindexes__ = input.readMessage(
                  VindexesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              vindexes_.getMutableMap().put(
                  vindexes__.getKey(), vindexes__.getValue());
              break;
            }
            case 26: {
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                tables_ = com.google.protobuf.MapField.newMapField(
                    TablesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000004;
              }
              com.google.protobuf.MapEntry<String, Table>
              tables__ = input.readMessage(
                  TablesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              tables_.getMutableMap().put(
                  tables__.getKey(), tables__.getValue());
              break;
            }
            case 32: {

              requireExplicitRouting_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Vschema.internal_static_vschema_Keyspace_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetVindexes();
        case 3:
          return internalGetTables();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Vschema.internal_static_vschema_Keyspace_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Keyspace.class, Builder.class);
    }

    private int bitField0_;
    public static final int SHARDED_FIELD_NUMBER = 1;
    private boolean sharded_;
    /**
     * <pre>
     * If sharded is false, vindexes and tables are ignored.
     * </pre>
     *
     * <code>bool sharded = 1;</code>
     */
    public boolean getSharded() {
      return sharded_;
    }

    public static final int VINDEXES_FIELD_NUMBER = 2;
    private static final class VindexesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          String, Vindex> defaultEntry =
              com.google.protobuf.MapEntry
              .<String, Vindex>newDefaultInstance(
                  Vschema.internal_static_vschema_Keyspace_VindexesEntry_descriptor,
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  Vindex.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        String, Vindex> vindexes_;
    private com.google.protobuf.MapField<String, Vindex>
    internalGetVindexes() {
      if (vindexes_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            VindexesDefaultEntryHolder.defaultEntry);
      }
      return vindexes_;
    }

    public int getVindexesCount() {
      return internalGetVindexes().getMap().size();
    }
    /**
     * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
     */

    public boolean containsVindexes(
        String key) {
      if (key == null) { throw new NullPointerException(); }
      return internalGetVindexes().getMap().containsKey(key);
    }
    /**
     * Use {@link #getVindexesMap()} instead.
     */
    @Deprecated
    public java.util.Map<String, Vindex> getVindexes() {
      return getVindexesMap();
    }
    /**
     * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
     */

    public java.util.Map<String, Vindex> getVindexesMap() {
      return internalGetVindexes().getMap();
    }
    /**
     * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
     */

    public Vindex getVindexesOrDefault(
        String key,
        Vindex defaultValue) {
      if (key == null) { throw new NullPointerException(); }
      java.util.Map<String, Vindex> map =
          internalGetVindexes().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
     */

    public Vindex getVindexesOrThrow(
        String key) {
      if (key == null) { throw new NullPointerException(); }
      java.util.Map<String, Vindex> map =
          internalGetVindexes().getMap();
      if (!map.containsKey(key)) {
        throw new IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int TABLES_FIELD_NUMBER = 3;
    private static final class TablesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          String, Table> defaultEntry =
              com.google.protobuf.MapEntry
              .<String, Table>newDefaultInstance(
                  Vschema.internal_static_vschema_Keyspace_TablesEntry_descriptor,
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  Table.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        String, Table> tables_;
    private com.google.protobuf.MapField<String, Table>
    internalGetTables() {
      if (tables_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            TablesDefaultEntryHolder.defaultEntry);
      }
      return tables_;
    }

    public int getTablesCount() {
      return internalGetTables().getMap().size();
    }
    /**
     * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
     */

    public boolean containsTables(
        String key) {
      if (key == null) { throw new NullPointerException(); }
      return internalGetTables().getMap().containsKey(key);
    }
    /**
     * Use {@link #getTablesMap()} instead.
     */
    @Deprecated
    public java.util.Map<String, Table> getTables() {
      return getTablesMap();
    }
    /**
     * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
     */

    public java.util.Map<String, Table> getTablesMap() {
      return internalGetTables().getMap();
    }
    /**
     * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
     */

    public Table getTablesOrDefault(
        String key,
        Table defaultValue) {
      if (key == null) { throw new NullPointerException(); }
      java.util.Map<String, Table> map =
          internalGetTables().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
     */

    public Table getTablesOrThrow(
        String key) {
      if (key == null) { throw new NullPointerException(); }
      java.util.Map<String, Table> map =
          internalGetTables().getMap();
      if (!map.containsKey(key)) {
        throw new IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int REQUIRE_EXPLICIT_ROUTING_FIELD_NUMBER = 4;
    private boolean requireExplicitRouting_;
    /**
     * <pre>
     * If require_explicit_routing is true, vindexes and tables are not added to global routing
     * </pre>
     *
     * <code>bool require_explicit_routing = 4;</code>
     */
    public boolean getRequireExplicitRouting() {
      return requireExplicitRouting_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (sharded_ != false) {
        output.writeBool(1, sharded_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetVindexes(),
          VindexesDefaultEntryHolder.defaultEntry,
          2);
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetTables(),
          TablesDefaultEntryHolder.defaultEntry,
          3);
      if (requireExplicitRouting_ != false) {
        output.writeBool(4, requireExplicitRouting_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (sharded_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(1, sharded_);
      }
      for (java.util.Map.Entry<String, Vindex> entry
           : internalGetVindexes().getMap().entrySet()) {
        com.google.protobuf.MapEntry<String, Vindex>
        vindexes__ = VindexesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, vindexes__);
      }
      for (java.util.Map.Entry<String, Table> entry
           : internalGetTables().getMap().entrySet()) {
        com.google.protobuf.MapEntry<String, Table>
        tables__ = TablesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(3, tables__);
      }
      if (requireExplicitRouting_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(4, requireExplicitRouting_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Keyspace)) {
        return super.equals(obj);
      }
      Keyspace other = (Keyspace) obj;

      boolean result = true;
      result = result && (getSharded()
          == other.getSharded());
      result = result && internalGetVindexes().equals(
          other.internalGetVindexes());
      result = result && internalGetTables().equals(
          other.internalGetTables());
      result = result && (getRequireExplicitRouting()
          == other.getRequireExplicitRouting());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + SHARDED_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getSharded());
      if (!internalGetVindexes().getMap().isEmpty()) {
        hash = (37 * hash) + VINDEXES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetVindexes().hashCode();
      }
      if (!internalGetTables().getMap().isEmpty()) {
        hash = (37 * hash) + TABLES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetTables().hashCode();
      }
      hash = (37 * hash) + REQUIRE_EXPLICIT_ROUTING_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getRequireExplicitRouting());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Keyspace parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Keyspace parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Keyspace parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Keyspace parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Keyspace parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Keyspace parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Keyspace parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Keyspace parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static Keyspace parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static Keyspace parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Keyspace parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Keyspace parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Keyspace prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Keyspace is the vschema for a keyspace.
     * </pre>
     *
     * Protobuf type {@code vschema.Keyspace}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:vschema.Keyspace)
        KeyspaceOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Vschema.internal_static_vschema_Keyspace_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetVindexes();
          case 3:
            return internalGetTables();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableVindexes();
          case 3:
            return internalGetMutableTables();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Vschema.internal_static_vschema_Keyspace_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Keyspace.class, Builder.class);
      }

      // Construct using vschema.Vschema.Keyspace.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        sharded_ = false;

        internalGetMutableVindexes().clear();
        internalGetMutableTables().clear();
        requireExplicitRouting_ = false;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Vschema.internal_static_vschema_Keyspace_descriptor;
      }

      public Keyspace getDefaultInstanceForType() {
        return Keyspace.getDefaultInstance();
      }

      public Keyspace build() {
        Keyspace result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public Keyspace buildPartial() {
        Keyspace result = new Keyspace(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.sharded_ = sharded_;
        result.vindexes_ = internalGetVindexes();
        result.vindexes_.makeImmutable();
        result.tables_ = internalGetTables();
        result.tables_.makeImmutable();
        result.requireExplicitRouting_ = requireExplicitRouting_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Keyspace) {
          return mergeFrom((Keyspace)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Keyspace other) {
        if (other == Keyspace.getDefaultInstance()) return this;
        if (other.getSharded() != false) {
          setSharded(other.getSharded());
        }
        internalGetMutableVindexes().mergeFrom(
            other.internalGetVindexes());
        internalGetMutableTables().mergeFrom(
            other.internalGetTables());
        if (other.getRequireExplicitRouting() != false) {
          setRequireExplicitRouting(other.getRequireExplicitRouting());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        Keyspace parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (Keyspace) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private boolean sharded_ ;
      /**
       * <pre>
       * If sharded is false, vindexes and tables are ignored.
       * </pre>
       *
       * <code>bool sharded = 1;</code>
       */
      public boolean getSharded() {
        return sharded_;
      }
      /**
       * <pre>
       * If sharded is false, vindexes and tables are ignored.
       * </pre>
       *
       * <code>bool sharded = 1;</code>
       */
      public Builder setSharded(boolean value) {
        
        sharded_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If sharded is false, vindexes and tables are ignored.
       * </pre>
       *
       * <code>bool sharded = 1;</code>
       */
      public Builder clearSharded() {
        
        sharded_ = false;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          String, Vindex> vindexes_;
      private com.google.protobuf.MapField<String, Vindex>
      internalGetVindexes() {
        if (vindexes_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              VindexesDefaultEntryHolder.defaultEntry);
        }
        return vindexes_;
      }
      private com.google.protobuf.MapField<String, Vindex>
      internalGetMutableVindexes() {
        onChanged();;
        if (vindexes_ == null) {
          vindexes_ = com.google.protobuf.MapField.newMapField(
              VindexesDefaultEntryHolder.defaultEntry);
        }
        if (!vindexes_.isMutable()) {
          vindexes_ = vindexes_.copy();
        }
        return vindexes_;
      }

      public int getVindexesCount() {
        return internalGetVindexes().getMap().size();
      }
      /**
       * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
       */

      public boolean containsVindexes(
          String key) {
        if (key == null) { throw new NullPointerException(); }
        return internalGetVindexes().getMap().containsKey(key);
      }
      /**
       * Use {@link #getVindexesMap()} instead.
       */
      @Deprecated
      public java.util.Map<String, Vindex> getVindexes() {
        return getVindexesMap();
      }
      /**
       * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
       */

      public java.util.Map<String, Vindex> getVindexesMap() {
        return internalGetVindexes().getMap();
      }
      /**
       * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
       */

      public Vindex getVindexesOrDefault(
          String key,
          Vindex defaultValue) {
        if (key == null) { throw new NullPointerException(); }
        java.util.Map<String, Vindex> map =
            internalGetVindexes().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
       */

      public Vindex getVindexesOrThrow(
          String key) {
        if (key == null) { throw new NullPointerException(); }
        java.util.Map<String, Vindex> map =
            internalGetVindexes().getMap();
        if (!map.containsKey(key)) {
          throw new IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearVindexes() {
        internalGetMutableVindexes().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
       */

      public Builder removeVindexes(
          String key) {
        if (key == null) { throw new NullPointerException(); }
        internalGetMutableVindexes().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @Deprecated
      public java.util.Map<String, Vindex>
      getMutableVindexes() {
        return internalGetMutableVindexes().getMutableMap();
      }
      /**
       * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
       */
      public Builder putVindexes(
          String key,
          Vindex value) {
        if (key == null) { throw new NullPointerException(); }
        if (value == null) { throw new NullPointerException(); }
        internalGetMutableVindexes().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, .vschema.Vindex&gt; vindexes = 2;</code>
       */

      public Builder putAllVindexes(
          java.util.Map<String, Vindex> values) {
        internalGetMutableVindexes().getMutableMap()
            .putAll(values);
        return this;
      }

      private com.google.protobuf.MapField<
          String, Table> tables_;
      private com.google.protobuf.MapField<String, Table>
      internalGetTables() {
        if (tables_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              TablesDefaultEntryHolder.defaultEntry);
        }
        return tables_;
      }
      private com.google.protobuf.MapField<String, Table>
      internalGetMutableTables() {
        onChanged();;
        if (tables_ == null) {
          tables_ = com.google.protobuf.MapField.newMapField(
              TablesDefaultEntryHolder.defaultEntry);
        }
        if (!tables_.isMutable()) {
          tables_ = tables_.copy();
        }
        return tables_;
      }

      public int getTablesCount() {
        return internalGetTables().getMap().size();
      }
      /**
       * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
       */

      public boolean containsTables(
          String key) {
        if (key == null) { throw new NullPointerException(); }
        return internalGetTables().getMap().containsKey(key);
      }
      /**
       * Use {@link #getTablesMap()} instead.
       */
      @Deprecated
      public java.util.Map<String, Table> getTables() {
        return getTablesMap();
      }
      /**
       * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
       */

      public java.util.Map<String, Table> getTablesMap() {
        return internalGetTables().getMap();
      }
      /**
       * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
       */

      public Table getTablesOrDefault(
          String key,
          Table defaultValue) {
        if (key == null) { throw new NullPointerException(); }
        java.util.Map<String, Table> map =
            internalGetTables().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
       */

      public Table getTablesOrThrow(
          String key) {
        if (key == null) { throw new NullPointerException(); }
        java.util.Map<String, Table> map =
            internalGetTables().getMap();
        if (!map.containsKey(key)) {
          throw new IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearTables() {
        internalGetMutableTables().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
       */

      public Builder removeTables(
          String key) {
        if (key == null) { throw new NullPointerException(); }
        internalGetMutableTables().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @Deprecated
      public java.util.Map<String, Table>
      getMutableTables() {
        return internalGetMutableTables().getMutableMap();
      }
      /**
       * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
       */
      public Builder putTables(
          String key,
          Table value) {
        if (key == null) { throw new NullPointerException(); }
        if (value == null) { throw new NullPointerException(); }
        internalGetMutableTables().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <code>map&lt;string, .vschema.Table&gt; tables = 3;</code>
       */

      public Builder putAllTables(
          java.util.Map<String, Table> values) {
        internalGetMutableTables().getMutableMap()
            .putAll(values);
        return this;
      }

      private boolean requireExplicitRouting_ ;
      /**
       * <pre>
       * If require_explicit_routing is true, vindexes and tables are not added to global routing
       * </pre>
       *
       * <code>bool require_explicit_routing = 4;</code>
       */
      public boolean getRequireExplicitRouting() {
        return requireExplicitRouting_;
      }
      /**
       * <pre>
       * If require_explicit_routing is true, vindexes and tables are not added to global routing
       * </pre>
       *
       * <code>bool require_explicit_routing = 4;</code>
       */
      public Builder setRequireExplicitRouting(boolean value) {
        
        requireExplicitRouting_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If require_explicit_routing is true, vindexes and tables are not added to global routing
       * </pre>
       *
       * <code>bool require_explicit_routing = 4;</code>
       */
      public Builder clearRequireExplicitRouting() {
        
        requireExplicitRouting_ = false;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:vschema.Keyspace)
    }

    // @@protoc_insertion_point(class_scope:vschema.Keyspace)
    private static final Keyspace DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Keyspace();
    }

    public static Keyspace getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Keyspace>
        PARSER = new com.google.protobuf.AbstractParser<Keyspace>() {
      public Keyspace parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Keyspace(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Keyspace> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<Keyspace> getParserForType() {
      return PARSER;
    }

    public Keyspace getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface VindexOrBuilder extends
      // @@protoc_insertion_point(interface_extends:vschema.Vindex)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * The type must match one of the predefined
     * (or plugged in) vindex names.
     * </pre>
     *
     * <code>string type = 1;</code>
     */
    String getType();
    /**
     * <pre>
     * The type must match one of the predefined
     * (or plugged in) vindex names.
     * </pre>
     *
     * <code>string type = 1;</code>
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * params is a map of attribute value pairs
     * that must be defined as required by the
     * vindex constructors. The values can only
     * be strings.
     * </pre>
     *
     * <code>map&lt;string, string&gt; params = 2;</code>
     */
    int getParamsCount();
    /**
     * <pre>
     * params is a map of attribute value pairs
     * that must be defined as required by the
     * vindex constructors. The values can only
     * be strings.
     * </pre>
     *
     * <code>map&lt;string, string&gt; params = 2;</code>
     */
    boolean containsParams(
        String key);
    /**
     * Use {@link #getParamsMap()} instead.
     */
    @Deprecated
    java.util.Map<String, String>
    getParams();
    /**
     * <pre>
     * params is a map of attribute value pairs
     * that must be defined as required by the
     * vindex constructors. The values can only
     * be strings.
     * </pre>
     *
     * <code>map&lt;string, string&gt; params = 2;</code>
     */
    java.util.Map<String, String>
    getParamsMap();
    /**
     * <pre>
     * params is a map of attribute value pairs
     * that must be defined as required by the
     * vindex constructors. The values can only
     * be strings.
     * </pre>
     *
     * <code>map&lt;string, string&gt; params = 2;</code>
     */

    String getParamsOrDefault(
        String key,
        String defaultValue);
    /**
     * <pre>
     * params is a map of attribute value pairs
     * that must be defined as required by the
     * vindex constructors. The values can only
     * be strings.
     * </pre>
     *
     * <code>map&lt;string, string&gt; params = 2;</code>
     */

    String getParamsOrThrow(
        String key);

    /**
     * <pre>
     * A lookup vindex can have an owner table defined.
     * If so, rows in the lookup table are created or
     * deleted in sync with corresponding rows in the
     * owner table.
     * </pre>
     *
     * <code>string owner = 3;</code>
     */
    String getOwner();
    /**
     * <pre>
     * A lookup vindex can have an owner table defined.
     * If so, rows in the lookup table are created or
     * deleted in sync with corresponding rows in the
     * owner table.
     * </pre>
     *
     * <code>string owner = 3;</code>
     */
    com.google.protobuf.ByteString
        getOwnerBytes();
  }
  /**
   * <pre>
   * Vindex is the vindex info for a Keyspace.
   * </pre>
   *
   * Protobuf type {@code vschema.Vindex}
   */
  public  static final class Vindex extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:vschema.Vindex)
      VindexOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Vindex.newBuilder() to construct.
    private Vindex(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Vindex() {
      type_ = "";
      owner_ = "";
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Vindex(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              String s = input.readStringRequireUtf8();

              type_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                params_ = com.google.protobuf.MapField.newMapField(
                    ParamsDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000002;
              }
              com.google.protobuf.MapEntry<String, String>
              params__ = input.readMessage(
                  ParamsDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              params_.getMutableMap().put(
                  params__.getKey(), params__.getValue());
              break;
            }
            case 26: {
              String s = input.readStringRequireUtf8();

              owner_ = s;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Vschema.internal_static_vschema_Vindex_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 2:
          return internalGetParams();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Vschema.internal_static_vschema_Vindex_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Vindex.class, Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile Object type_;
    /**
     * <pre>
     * The type must match one of the predefined
     * (or plugged in) vindex names.
     * </pre>
     *
     * <code>string type = 1;</code>
     */
    public String getType() {
      Object ref = type_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        type_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The type must match one of the predefined
     * (or plugged in) vindex names.
     * </pre>
     *
     * <code>string type = 1;</code>
     */
    public com.google.protobuf.ByteString
        getTypeBytes() {
      Object ref = type_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int PARAMS_FIELD_NUMBER = 2;
    private static final class ParamsDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          String, String> defaultEntry =
              com.google.protobuf.MapEntry
              .<String, String>newDefaultInstance(
                  Vschema.internal_static_vschema_Vindex_ParamsEntry_descriptor,
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "");
    }
    private com.google.protobuf.MapField<
        String, String> params_;
    private com.google.protobuf.MapField<String, String>
    internalGetParams() {
      if (params_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            ParamsDefaultEntryHolder.defaultEntry);
      }
      return params_;
    }

    public int getParamsCount() {
      return internalGetParams().getMap().size();
    }
    /**
     * <pre>
     * params is a map of attribute value pairs
     * that must be defined as required by the
     * vindex constructors. The values can only
     * be strings.
     * </pre>
     *
     * <code>map&lt;string, string&gt; params = 2;</code>
     */

    public boolean containsParams(
        String key) {
      if (key == null) { throw new NullPointerException(); }
      return internalGetParams().getMap().containsKey(key);
    }
    /**
     * Use {@link #getParamsMap()} instead.
     */
    @Deprecated
    public java.util.Map<String, String> getParams() {
      return getParamsMap();
    }
    /**
     * <pre>
     * params is a map of attribute value pairs
     * that must be defined as required by the
     * vindex constructors. The values can only
     * be strings.
     * </pre>
     *
     * <code>map&lt;string, string&gt; params = 2;</code>
     */

    public java.util.Map<String, String> getParamsMap() {
      return internalGetParams().getMap();
    }
    /**
     * <pre>
     * params is a map of attribute value pairs
     * that must be defined as required by the
     * vindex constructors. The values can only
     * be strings.
     * </pre>
     *
     * <code>map&lt;string, string&gt; params = 2;</code>
     */

    public String getParamsOrDefault(
        String key,
        String defaultValue) {
      if (key == null) { throw new NullPointerException(); }
      java.util.Map<String, String> map =
          internalGetParams().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * params is a map of attribute value pairs
     * that must be defined as required by the
     * vindex constructors. The values can only
     * be strings.
     * </pre>
     *
     * <code>map&lt;string, string&gt; params = 2;</code>
     */

    public String getParamsOrThrow(
        String key) {
      if (key == null) { throw new NullPointerException(); }
      java.util.Map<String, String> map =
          internalGetParams().getMap();
      if (!map.containsKey(key)) {
        throw new IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int OWNER_FIELD_NUMBER = 3;
    private volatile Object owner_;
    /**
     * <pre>
     * A lookup vindex can have an owner table defined.
     * If so, rows in the lookup table are created or
     * deleted in sync with corresponding rows in the
     * owner table.
     * </pre>
     *
     * <code>string owner = 3;</code>
     */
    public String getOwner() {
      Object ref = owner_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        owner_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * A lookup vindex can have an owner table defined.
     * If so, rows in the lookup table are created or
     * deleted in sync with corresponding rows in the
     * owner table.
     * </pre>
     *
     * <code>string owner = 3;</code>
     */
    public com.google.protobuf.ByteString
        getOwnerBytes() {
      Object ref = owner_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        owner_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getTypeBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetParams(),
          ParamsDefaultEntryHolder.defaultEntry,
          2);
      if (!getOwnerBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, owner_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getTypeBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      for (java.util.Map.Entry<String, String> entry
           : internalGetParams().getMap().entrySet()) {
        com.google.protobuf.MapEntry<String, String>
        params__ = ParamsDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(2, params__);
      }
      if (!getOwnerBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(3, owner_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Vindex)) {
        return super.equals(obj);
      }
      Vindex other = (Vindex) obj;

      boolean result = true;
      result = result && getType()
          .equals(other.getType());
      result = result && internalGetParams().equals(
          other.internalGetParams());
      result = result && getOwner()
          .equals(other.getOwner());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getType().hashCode();
      if (!internalGetParams().getMap().isEmpty()) {
        hash = (37 * hash) + PARAMS_FIELD_NUMBER;
        hash = (53 * hash) + internalGetParams().hashCode();
      }
      hash = (37 * hash) + OWNER_FIELD_NUMBER;
      hash = (53 * hash) + getOwner().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Vindex parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Vindex parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Vindex parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Vindex parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Vindex parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Vindex parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Vindex parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Vindex parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static Vindex parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static Vindex parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Vindex parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Vindex parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Vindex prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Vindex is the vindex info for a Keyspace.
     * </pre>
     *
     * Protobuf type {@code vschema.Vindex}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:vschema.Vindex)
        VindexOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Vschema.internal_static_vschema_Vindex_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetParams();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 2:
            return internalGetMutableParams();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Vschema.internal_static_vschema_Vindex_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Vindex.class, Builder.class);
      }

      // Construct using vschema.Vschema.Vindex.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        type_ = "";

        internalGetMutableParams().clear();
        owner_ = "";

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Vschema.internal_static_vschema_Vindex_descriptor;
      }

      public Vindex getDefaultInstanceForType() {
        return Vindex.getDefaultInstance();
      }

      public Vindex build() {
        Vindex result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public Vindex buildPartial() {
        Vindex result = new Vindex(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.type_ = type_;
        result.params_ = internalGetParams();
        result.params_.makeImmutable();
        result.owner_ = owner_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Vindex) {
          return mergeFrom((Vindex)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Vindex other) {
        if (other == Vindex.getDefaultInstance()) return this;
        if (!other.getType().isEmpty()) {
          type_ = other.type_;
          onChanged();
        }
        internalGetMutableParams().mergeFrom(
            other.internalGetParams());
        if (!other.getOwner().isEmpty()) {
          owner_ = other.owner_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        Vindex parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (Vindex) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private Object type_ = "";
      /**
       * <pre>
       * The type must match one of the predefined
       * (or plugged in) vindex names.
       * </pre>
       *
       * <code>string type = 1;</code>
       */
      public String getType() {
        Object ref = type_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          type_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * The type must match one of the predefined
       * (or plugged in) vindex names.
       * </pre>
       *
       * <code>string type = 1;</code>
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The type must match one of the predefined
       * (or plugged in) vindex names.
       * </pre>
       *
       * <code>string type = 1;</code>
       */
      public Builder setType(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The type must match one of the predefined
       * (or plugged in) vindex names.
       * </pre>
       *
       * <code>string type = 1;</code>
       */
      public Builder clearType() {
        
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The type must match one of the predefined
       * (or plugged in) vindex names.
       * </pre>
       *
       * <code>string type = 1;</code>
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        type_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.MapField<
          String, String> params_;
      private com.google.protobuf.MapField<String, String>
      internalGetParams() {
        if (params_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              ParamsDefaultEntryHolder.defaultEntry);
        }
        return params_;
      }
      private com.google.protobuf.MapField<String, String>
      internalGetMutableParams() {
        onChanged();;
        if (params_ == null) {
          params_ = com.google.protobuf.MapField.newMapField(
              ParamsDefaultEntryHolder.defaultEntry);
        }
        if (!params_.isMutable()) {
          params_ = params_.copy();
        }
        return params_;
      }

      public int getParamsCount() {
        return internalGetParams().getMap().size();
      }
      /**
       * <pre>
       * params is a map of attribute value pairs
       * that must be defined as required by the
       * vindex constructors. The values can only
       * be strings.
       * </pre>
       *
       * <code>map&lt;string, string&gt; params = 2;</code>
       */

      public boolean containsParams(
          String key) {
        if (key == null) { throw new NullPointerException(); }
        return internalGetParams().getMap().containsKey(key);
      }
      /**
       * Use {@link #getParamsMap()} instead.
       */
      @Deprecated
      public java.util.Map<String, String> getParams() {
        return getParamsMap();
      }
      /**
       * <pre>
       * params is a map of attribute value pairs
       * that must be defined as required by the
       * vindex constructors. The values can only
       * be strings.
       * </pre>
       *
       * <code>map&lt;string, string&gt; params = 2;</code>
       */

      public java.util.Map<String, String> getParamsMap() {
        return internalGetParams().getMap();
      }
      /**
       * <pre>
       * params is a map of attribute value pairs
       * that must be defined as required by the
       * vindex constructors. The values can only
       * be strings.
       * </pre>
       *
       * <code>map&lt;string, string&gt; params = 2;</code>
       */

      public String getParamsOrDefault(
          String key,
          String defaultValue) {
        if (key == null) { throw new NullPointerException(); }
        java.util.Map<String, String> map =
            internalGetParams().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * params is a map of attribute value pairs
       * that must be defined as required by the
       * vindex constructors. The values can only
       * be strings.
       * </pre>
       *
       * <code>map&lt;string, string&gt; params = 2;</code>
       */

      public String getParamsOrThrow(
          String key) {
        if (key == null) { throw new NullPointerException(); }
        java.util.Map<String, String> map =
            internalGetParams().getMap();
        if (!map.containsKey(key)) {
          throw new IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearParams() {
        internalGetMutableParams().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * params is a map of attribute value pairs
       * that must be defined as required by the
       * vindex constructors. The values can only
       * be strings.
       * </pre>
       *
       * <code>map&lt;string, string&gt; params = 2;</code>
       */

      public Builder removeParams(
          String key) {
        if (key == null) { throw new NullPointerException(); }
        internalGetMutableParams().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @Deprecated
      public java.util.Map<String, String>
      getMutableParams() {
        return internalGetMutableParams().getMutableMap();
      }
      /**
       * <pre>
       * params is a map of attribute value pairs
       * that must be defined as required by the
       * vindex constructors. The values can only
       * be strings.
       * </pre>
       *
       * <code>map&lt;string, string&gt; params = 2;</code>
       */
      public Builder putParams(
          String key,
          String value) {
        if (key == null) { throw new NullPointerException(); }
        if (value == null) { throw new NullPointerException(); }
        internalGetMutableParams().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * params is a map of attribute value pairs
       * that must be defined as required by the
       * vindex constructors. The values can only
       * be strings.
       * </pre>
       *
       * <code>map&lt;string, string&gt; params = 2;</code>
       */

      public Builder putAllParams(
          java.util.Map<String, String> values) {
        internalGetMutableParams().getMutableMap()
            .putAll(values);
        return this;
      }

      private Object owner_ = "";
      /**
       * <pre>
       * A lookup vindex can have an owner table defined.
       * If so, rows in the lookup table are created or
       * deleted in sync with corresponding rows in the
       * owner table.
       * </pre>
       *
       * <code>string owner = 3;</code>
       */
      public String getOwner() {
        Object ref = owner_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          owner_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * A lookup vindex can have an owner table defined.
       * If so, rows in the lookup table are created or
       * deleted in sync with corresponding rows in the
       * owner table.
       * </pre>
       *
       * <code>string owner = 3;</code>
       */
      public com.google.protobuf.ByteString
          getOwnerBytes() {
        Object ref = owner_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          owner_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * A lookup vindex can have an owner table defined.
       * If so, rows in the lookup table are created or
       * deleted in sync with corresponding rows in the
       * owner table.
       * </pre>
       *
       * <code>string owner = 3;</code>
       */
      public Builder setOwner(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        owner_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A lookup vindex can have an owner table defined.
       * If so, rows in the lookup table are created or
       * deleted in sync with corresponding rows in the
       * owner table.
       * </pre>
       *
       * <code>string owner = 3;</code>
       */
      public Builder clearOwner() {
        
        owner_ = getDefaultInstance().getOwner();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * A lookup vindex can have an owner table defined.
       * If so, rows in the lookup table are created or
       * deleted in sync with corresponding rows in the
       * owner table.
       * </pre>
       *
       * <code>string owner = 3;</code>
       */
      public Builder setOwnerBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        owner_ = value;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:vschema.Vindex)
    }

    // @@protoc_insertion_point(class_scope:vschema.Vindex)
    private static final Vindex DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Vindex();
    }

    public static Vindex getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Vindex>
        PARSER = new com.google.protobuf.AbstractParser<Vindex>() {
      public Vindex parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Vindex(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Vindex> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<Vindex> getParserForType() {
      return PARSER;
    }

    public Vindex getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface TableOrBuilder extends
      // @@protoc_insertion_point(interface_extends:vschema.Table)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * If the table is a sequence, type must be
     * "sequence". Otherwise, it should be empty.
     * </pre>
     *
     * <code>string type = 1;</code>
     */
    String getType();
    /**
     * <pre>
     * If the table is a sequence, type must be
     * "sequence". Otherwise, it should be empty.
     * </pre>
     *
     * <code>string type = 1;</code>
     */
    com.google.protobuf.ByteString
        getTypeBytes();

    /**
     * <pre>
     * column_vindexes associates columns to vindexes.
     * </pre>
     *
     * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
     */
    java.util.List<ColumnVindex>
        getColumnVindexesList();
    /**
     * <pre>
     * column_vindexes associates columns to vindexes.
     * </pre>
     *
     * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
     */
    ColumnVindex getColumnVindexes(int index);
    /**
     * <pre>
     * column_vindexes associates columns to vindexes.
     * </pre>
     *
     * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
     */
    int getColumnVindexesCount();
    /**
     * <pre>
     * column_vindexes associates columns to vindexes.
     * </pre>
     *
     * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
     */
    java.util.List<? extends ColumnVindexOrBuilder>
        getColumnVindexesOrBuilderList();
    /**
     * <pre>
     * column_vindexes associates columns to vindexes.
     * </pre>
     *
     * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
     */
    ColumnVindexOrBuilder getColumnVindexesOrBuilder(
        int index);

    /**
     * <pre>
     * auto_increment is specified if a column needs
     * to be associated with a sequence.
     * </pre>
     *
     * <code>.vschema.AutoIncrement auto_increment = 3;</code>
     */
    boolean hasAutoIncrement();
    /**
     * <pre>
     * auto_increment is specified if a column needs
     * to be associated with a sequence.
     * </pre>
     *
     * <code>.vschema.AutoIncrement auto_increment = 3;</code>
     */
    AutoIncrement getAutoIncrement();
    /**
     * <pre>
     * auto_increment is specified if a column needs
     * to be associated with a sequence.
     * </pre>
     *
     * <code>.vschema.AutoIncrement auto_increment = 3;</code>
     */
    AutoIncrementOrBuilder getAutoIncrementOrBuilder();

    /**
     * <pre>
     * columns lists the columns for the table.
     * </pre>
     *
     * <code>repeated .vschema.Column columns = 4;</code>
     */
    java.util.List<Column>
        getColumnsList();
    /**
     * <pre>
     * columns lists the columns for the table.
     * </pre>
     *
     * <code>repeated .vschema.Column columns = 4;</code>
     */
    Column getColumns(int index);
    /**
     * <pre>
     * columns lists the columns for the table.
     * </pre>
     *
     * <code>repeated .vschema.Column columns = 4;</code>
     */
    int getColumnsCount();
    /**
     * <pre>
     * columns lists the columns for the table.
     * </pre>
     *
     * <code>repeated .vschema.Column columns = 4;</code>
     */
    java.util.List<? extends ColumnOrBuilder>
        getColumnsOrBuilderList();
    /**
     * <pre>
     * columns lists the columns for the table.
     * </pre>
     *
     * <code>repeated .vschema.Column columns = 4;</code>
     */
    ColumnOrBuilder getColumnsOrBuilder(
        int index);

    /**
     * <pre>
     * pinned pins an unsharded table to a specific
     * shard, as dictated by the keyspace id.
     * The keyspace id is represented in hex form
     * like in keyranges.
     * </pre>
     *
     * <code>string pinned = 5;</code>
     */
    String getPinned();
    /**
     * <pre>
     * pinned pins an unsharded table to a specific
     * shard, as dictated by the keyspace id.
     * The keyspace id is represented in hex form
     * like in keyranges.
     * </pre>
     *
     * <code>string pinned = 5;</code>
     */
    com.google.protobuf.ByteString
        getPinnedBytes();

    /**
     * <pre>
     * column_list_authoritative is set to true if columns is
     * an authoritative list for the table. This allows
     * us to expand 'select *' expressions.
     * </pre>
     *
     * <code>bool column_list_authoritative = 6;</code>
     */
    boolean getColumnListAuthoritative();
  }
  /**
   * <pre>
   * Table is the table info for a Keyspace.
   * </pre>
   *
   * Protobuf type {@code vschema.Table}
   */
  public  static final class Table extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:vschema.Table)
      TableOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Table.newBuilder() to construct.
    private Table(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Table() {
      type_ = "";
      columnVindexes_ = java.util.Collections.emptyList();
      columns_ = java.util.Collections.emptyList();
      pinned_ = "";
      columnListAuthoritative_ = false;
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Table(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              String s = input.readStringRequireUtf8();

              type_ = s;
              break;
            }
            case 18: {
              if (!((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
                columnVindexes_ = new java.util.ArrayList<ColumnVindex>();
                mutable_bitField0_ |= 0x00000002;
              }
              columnVindexes_.add(
                  input.readMessage(ColumnVindex.parser(), extensionRegistry));
              break;
            }
            case 26: {
              AutoIncrement.Builder subBuilder = null;
              if (autoIncrement_ != null) {
                subBuilder = autoIncrement_.toBuilder();
              }
              autoIncrement_ = input.readMessage(AutoIncrement.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(autoIncrement_);
                autoIncrement_ = subBuilder.buildPartial();
              }

              break;
            }
            case 34: {
              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
                columns_ = new java.util.ArrayList<Column>();
                mutable_bitField0_ |= 0x00000008;
              }
              columns_.add(
                  input.readMessage(Column.parser(), extensionRegistry));
              break;
            }
            case 42: {
              String s = input.readStringRequireUtf8();

              pinned_ = s;
              break;
            }
            case 48: {

              columnListAuthoritative_ = input.readBool();
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000002) == 0x00000002)) {
          columnVindexes_ = java.util.Collections.unmodifiableList(columnVindexes_);
        }
        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {
          columns_ = java.util.Collections.unmodifiableList(columns_);
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Vschema.internal_static_vschema_Table_descriptor;
    }

    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Vschema.internal_static_vschema_Table_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Table.class, Builder.class);
    }

    private int bitField0_;
    public static final int TYPE_FIELD_NUMBER = 1;
    private volatile Object type_;
    /**
     * <pre>
     * If the table is a sequence, type must be
     * "sequence". Otherwise, it should be empty.
     * </pre>
     *
     * <code>string type = 1;</code>
     */
    public String getType() {
      Object ref = type_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        type_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * If the table is a sequence, type must be
     * "sequence". Otherwise, it should be empty.
     * </pre>
     *
     * <code>string type = 1;</code>
     */
    public com.google.protobuf.ByteString
        getTypeBytes() {
      Object ref = type_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        type_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int COLUMN_VINDEXES_FIELD_NUMBER = 2;
    private java.util.List<ColumnVindex> columnVindexes_;
    /**
     * <pre>
     * column_vindexes associates columns to vindexes.
     * </pre>
     *
     * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
     */
    public java.util.List<ColumnVindex> getColumnVindexesList() {
      return columnVindexes_;
    }
    /**
     * <pre>
     * column_vindexes associates columns to vindexes.
     * </pre>
     *
     * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
     */
    public java.util.List<? extends ColumnVindexOrBuilder>
        getColumnVindexesOrBuilderList() {
      return columnVindexes_;
    }
    /**
     * <pre>
     * column_vindexes associates columns to vindexes.
     * </pre>
     *
     * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
     */
    public int getColumnVindexesCount() {
      return columnVindexes_.size();
    }
    /**
     * <pre>
     * column_vindexes associates columns to vindexes.
     * </pre>
     *
     * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
     */
    public ColumnVindex getColumnVindexes(int index) {
      return columnVindexes_.get(index);
    }
    /**
     * <pre>
     * column_vindexes associates columns to vindexes.
     * </pre>
     *
     * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
     */
    public ColumnVindexOrBuilder getColumnVindexesOrBuilder(
        int index) {
      return columnVindexes_.get(index);
    }

    public static final int AUTO_INCREMENT_FIELD_NUMBER = 3;
    private AutoIncrement autoIncrement_;
    /**
     * <pre>
     * auto_increment is specified if a column needs
     * to be associated with a sequence.
     * </pre>
     *
     * <code>.vschema.AutoIncrement auto_increment = 3;</code>
     */
    public boolean hasAutoIncrement() {
      return autoIncrement_ != null;
    }
    /**
     * <pre>
     * auto_increment is specified if a column needs
     * to be associated with a sequence.
     * </pre>
     *
     * <code>.vschema.AutoIncrement auto_increment = 3;</code>
     */
    public AutoIncrement getAutoIncrement() {
      return autoIncrement_ == null ? AutoIncrement.getDefaultInstance() : autoIncrement_;
    }
    /**
     * <pre>
     * auto_increment is specified if a column needs
     * to be associated with a sequence.
     * </pre>
     *
     * <code>.vschema.AutoIncrement auto_increment = 3;</code>
     */
    public AutoIncrementOrBuilder getAutoIncrementOrBuilder() {
      return getAutoIncrement();
    }

    public static final int COLUMNS_FIELD_NUMBER = 4;
    private java.util.List<Column> columns_;
    /**
     * <pre>
     * columns lists the columns for the table.
     * </pre>
     *
     * <code>repeated .vschema.Column columns = 4;</code>
     */
    public java.util.List<Column> getColumnsList() {
      return columns_;
    }
    /**
     * <pre>
     * columns lists the columns for the table.
     * </pre>
     *
     * <code>repeated .vschema.Column columns = 4;</code>
     */
    public java.util.List<? extends ColumnOrBuilder>
        getColumnsOrBuilderList() {
      return columns_;
    }
    /**
     * <pre>
     * columns lists the columns for the table.
     * </pre>
     *
     * <code>repeated .vschema.Column columns = 4;</code>
     */
    public int getColumnsCount() {
      return columns_.size();
    }
    /**
     * <pre>
     * columns lists the columns for the table.
     * </pre>
     *
     * <code>repeated .vschema.Column columns = 4;</code>
     */
    public Column getColumns(int index) {
      return columns_.get(index);
    }
    /**
     * <pre>
     * columns lists the columns for the table.
     * </pre>
     *
     * <code>repeated .vschema.Column columns = 4;</code>
     */
    public ColumnOrBuilder getColumnsOrBuilder(
        int index) {
      return columns_.get(index);
    }

    public static final int PINNED_FIELD_NUMBER = 5;
    private volatile Object pinned_;
    /**
     * <pre>
     * pinned pins an unsharded table to a specific
     * shard, as dictated by the keyspace id.
     * The keyspace id is represented in hex form
     * like in keyranges.
     * </pre>
     *
     * <code>string pinned = 5;</code>
     */
    public String getPinned() {
      Object ref = pinned_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        pinned_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * pinned pins an unsharded table to a specific
     * shard, as dictated by the keyspace id.
     * The keyspace id is represented in hex form
     * like in keyranges.
     * </pre>
     *
     * <code>string pinned = 5;</code>
     */
    public com.google.protobuf.ByteString
        getPinnedBytes() {
      Object ref = pinned_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        pinned_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int COLUMN_LIST_AUTHORITATIVE_FIELD_NUMBER = 6;
    private boolean columnListAuthoritative_;
    /**
     * <pre>
     * column_list_authoritative is set to true if columns is
     * an authoritative list for the table. This allows
     * us to expand 'select *' expressions.
     * </pre>
     *
     * <code>bool column_list_authoritative = 6;</code>
     */
    public boolean getColumnListAuthoritative() {
      return columnListAuthoritative_;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getTypeBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, type_);
      }
      for (int i = 0; i < columnVindexes_.size(); i++) {
        output.writeMessage(2, columnVindexes_.get(i));
      }
      if (autoIncrement_ != null) {
        output.writeMessage(3, getAutoIncrement());
      }
      for (int i = 0; i < columns_.size(); i++) {
        output.writeMessage(4, columns_.get(i));
      }
      if (!getPinnedBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 5, pinned_);
      }
      if (columnListAuthoritative_ != false) {
        output.writeBool(6, columnListAuthoritative_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getTypeBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, type_);
      }
      for (int i = 0; i < columnVindexes_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, columnVindexes_.get(i));
      }
      if (autoIncrement_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(3, getAutoIncrement());
      }
      for (int i = 0; i < columns_.size(); i++) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(4, columns_.get(i));
      }
      if (!getPinnedBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(5, pinned_);
      }
      if (columnListAuthoritative_ != false) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, columnListAuthoritative_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Table)) {
        return super.equals(obj);
      }
      Table other = (Table) obj;

      boolean result = true;
      result = result && getType()
          .equals(other.getType());
      result = result && getColumnVindexesList()
          .equals(other.getColumnVindexesList());
      result = result && (hasAutoIncrement() == other.hasAutoIncrement());
      if (hasAutoIncrement()) {
        result = result && getAutoIncrement()
            .equals(other.getAutoIncrement());
      }
      result = result && getColumnsList()
          .equals(other.getColumnsList());
      result = result && getPinned()
          .equals(other.getPinned());
      result = result && (getColumnListAuthoritative()
          == other.getColumnListAuthoritative());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + getType().hashCode();
      if (getColumnVindexesCount() > 0) {
        hash = (37 * hash) + COLUMN_VINDEXES_FIELD_NUMBER;
        hash = (53 * hash) + getColumnVindexesList().hashCode();
      }
      if (hasAutoIncrement()) {
        hash = (37 * hash) + AUTO_INCREMENT_FIELD_NUMBER;
        hash = (53 * hash) + getAutoIncrement().hashCode();
      }
      if (getColumnsCount() > 0) {
        hash = (37 * hash) + COLUMNS_FIELD_NUMBER;
        hash = (53 * hash) + getColumnsList().hashCode();
      }
      hash = (37 * hash) + PINNED_FIELD_NUMBER;
      hash = (53 * hash) + getPinned().hashCode();
      hash = (37 * hash) + COLUMN_LIST_AUTHORITATIVE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getColumnListAuthoritative());
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Table parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Table parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Table parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Table parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Table parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Table parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Table parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Table parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static Table parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static Table parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Table parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Table parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Table prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Table is the table info for a Keyspace.
     * </pre>
     *
     * Protobuf type {@code vschema.Table}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:vschema.Table)
        TableOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Vschema.internal_static_vschema_Table_descriptor;
      }

      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Vschema.internal_static_vschema_Table_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Table.class, Builder.class);
      }

      // Construct using vschema.Vschema.Table.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
          getColumnVindexesFieldBuilder();
          getColumnsFieldBuilder();
        }
      }
      public Builder clear() {
        super.clear();
        type_ = "";

        if (columnVindexesBuilder_ == null) {
          columnVindexes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
        } else {
          columnVindexesBuilder_.clear();
        }
        if (autoIncrementBuilder_ == null) {
          autoIncrement_ = null;
        } else {
          autoIncrement_ = null;
          autoIncrementBuilder_ = null;
        }
        if (columnsBuilder_ == null) {
          columns_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
        } else {
          columnsBuilder_.clear();
        }
        pinned_ = "";

        columnListAuthoritative_ = false;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Vschema.internal_static_vschema_Table_descriptor;
      }

      public Table getDefaultInstanceForType() {
        return Table.getDefaultInstance();
      }

      public Table build() {
        Table result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public Table buildPartial() {
        Table result = new Table(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.type_ = type_;
        if (columnVindexesBuilder_ == null) {
          if (((bitField0_ & 0x00000002) == 0x00000002)) {
            columnVindexes_ = java.util.Collections.unmodifiableList(columnVindexes_);
            bitField0_ = (bitField0_ & ~0x00000002);
          }
          result.columnVindexes_ = columnVindexes_;
        } else {
          result.columnVindexes_ = columnVindexesBuilder_.build();
        }
        if (autoIncrementBuilder_ == null) {
          result.autoIncrement_ = autoIncrement_;
        } else {
          result.autoIncrement_ = autoIncrementBuilder_.build();
        }
        if (columnsBuilder_ == null) {
          if (((bitField0_ & 0x00000008) == 0x00000008)) {
            columns_ = java.util.Collections.unmodifiableList(columns_);
            bitField0_ = (bitField0_ & ~0x00000008);
          }
          result.columns_ = columns_;
        } else {
          result.columns_ = columnsBuilder_.build();
        }
        result.pinned_ = pinned_;
        result.columnListAuthoritative_ = columnListAuthoritative_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Table) {
          return mergeFrom((Table)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Table other) {
        if (other == Table.getDefaultInstance()) return this;
        if (!other.getType().isEmpty()) {
          type_ = other.type_;
          onChanged();
        }
        if (columnVindexesBuilder_ == null) {
          if (!other.columnVindexes_.isEmpty()) {
            if (columnVindexes_.isEmpty()) {
              columnVindexes_ = other.columnVindexes_;
              bitField0_ = (bitField0_ & ~0x00000002);
            } else {
              ensureColumnVindexesIsMutable();
              columnVindexes_.addAll(other.columnVindexes_);
            }
            onChanged();
          }
        } else {
          if (!other.columnVindexes_.isEmpty()) {
            if (columnVindexesBuilder_.isEmpty()) {
              columnVindexesBuilder_.dispose();
              columnVindexesBuilder_ = null;
              columnVindexes_ = other.columnVindexes_;
              bitField0_ = (bitField0_ & ~0x00000002);
              columnVindexesBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getColumnVindexesFieldBuilder() : null;
            } else {
              columnVindexesBuilder_.addAllMessages(other.columnVindexes_);
            }
          }
        }
        if (other.hasAutoIncrement()) {
          mergeAutoIncrement(other.getAutoIncrement());
        }
        if (columnsBuilder_ == null) {
          if (!other.columns_.isEmpty()) {
            if (columns_.isEmpty()) {
              columns_ = other.columns_;
              bitField0_ = (bitField0_ & ~0x00000008);
            } else {
              ensureColumnsIsMutable();
              columns_.addAll(other.columns_);
            }
            onChanged();
          }
        } else {
          if (!other.columns_.isEmpty()) {
            if (columnsBuilder_.isEmpty()) {
              columnsBuilder_.dispose();
              columnsBuilder_ = null;
              columns_ = other.columns_;
              bitField0_ = (bitField0_ & ~0x00000008);
              columnsBuilder_ = 
                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?
                   getColumnsFieldBuilder() : null;
            } else {
              columnsBuilder_.addAllMessages(other.columns_);
            }
          }
        }
        if (!other.getPinned().isEmpty()) {
          pinned_ = other.pinned_;
          onChanged();
        }
        if (other.getColumnListAuthoritative() != false) {
          setColumnListAuthoritative(other.getColumnListAuthoritative());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        Table parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (Table) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private Object type_ = "";
      /**
       * <pre>
       * If the table is a sequence, type must be
       * "sequence". Otherwise, it should be empty.
       * </pre>
       *
       * <code>string type = 1;</code>
       */
      public String getType() {
        Object ref = type_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          type_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * If the table is a sequence, type must be
       * "sequence". Otherwise, it should be empty.
       * </pre>
       *
       * <code>string type = 1;</code>
       */
      public com.google.protobuf.ByteString
          getTypeBytes() {
        Object ref = type_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          type_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * If the table is a sequence, type must be
       * "sequence". Otherwise, it should be empty.
       * </pre>
       *
       * <code>string type = 1;</code>
       */
      public Builder setType(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If the table is a sequence, type must be
       * "sequence". Otherwise, it should be empty.
       * </pre>
       *
       * <code>string type = 1;</code>
       */
      public Builder clearType() {
        
        type_ = getDefaultInstance().getType();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If the table is a sequence, type must be
       * "sequence". Otherwise, it should be empty.
       * </pre>
       *
       * <code>string type = 1;</code>
       */
      public Builder setTypeBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        type_ = value;
        onChanged();
        return this;
      }

      private java.util.List<ColumnVindex> columnVindexes_ =
        java.util.Collections.emptyList();
      private void ensureColumnVindexesIsMutable() {
        if (!((bitField0_ & 0x00000002) == 0x00000002)) {
          columnVindexes_ = new java.util.ArrayList<ColumnVindex>(columnVindexes_);
          bitField0_ |= 0x00000002;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          ColumnVindex, ColumnVindex.Builder, ColumnVindexOrBuilder> columnVindexesBuilder_;

      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public java.util.List<ColumnVindex> getColumnVindexesList() {
        if (columnVindexesBuilder_ == null) {
          return java.util.Collections.unmodifiableList(columnVindexes_);
        } else {
          return columnVindexesBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public int getColumnVindexesCount() {
        if (columnVindexesBuilder_ == null) {
          return columnVindexes_.size();
        } else {
          return columnVindexesBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public ColumnVindex getColumnVindexes(int index) {
        if (columnVindexesBuilder_ == null) {
          return columnVindexes_.get(index);
        } else {
          return columnVindexesBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public Builder setColumnVindexes(
          int index, ColumnVindex value) {
        if (columnVindexesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureColumnVindexesIsMutable();
          columnVindexes_.set(index, value);
          onChanged();
        } else {
          columnVindexesBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public Builder setColumnVindexes(
          int index, ColumnVindex.Builder builderForValue) {
        if (columnVindexesBuilder_ == null) {
          ensureColumnVindexesIsMutable();
          columnVindexes_.set(index, builderForValue.build());
          onChanged();
        } else {
          columnVindexesBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public Builder addColumnVindexes(ColumnVindex value) {
        if (columnVindexesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureColumnVindexesIsMutable();
          columnVindexes_.add(value);
          onChanged();
        } else {
          columnVindexesBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public Builder addColumnVindexes(
          int index, ColumnVindex value) {
        if (columnVindexesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureColumnVindexesIsMutable();
          columnVindexes_.add(index, value);
          onChanged();
        } else {
          columnVindexesBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public Builder addColumnVindexes(
          ColumnVindex.Builder builderForValue) {
        if (columnVindexesBuilder_ == null) {
          ensureColumnVindexesIsMutable();
          columnVindexes_.add(builderForValue.build());
          onChanged();
        } else {
          columnVindexesBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public Builder addColumnVindexes(
          int index, ColumnVindex.Builder builderForValue) {
        if (columnVindexesBuilder_ == null) {
          ensureColumnVindexesIsMutable();
          columnVindexes_.add(index, builderForValue.build());
          onChanged();
        } else {
          columnVindexesBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public Builder addAllColumnVindexes(
          Iterable<? extends ColumnVindex> values) {
        if (columnVindexesBuilder_ == null) {
          ensureColumnVindexesIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, columnVindexes_);
          onChanged();
        } else {
          columnVindexesBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public Builder clearColumnVindexes() {
        if (columnVindexesBuilder_ == null) {
          columnVindexes_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000002);
          onChanged();
        } else {
          columnVindexesBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public Builder removeColumnVindexes(int index) {
        if (columnVindexesBuilder_ == null) {
          ensureColumnVindexesIsMutable();
          columnVindexes_.remove(index);
          onChanged();
        } else {
          columnVindexesBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public ColumnVindex.Builder getColumnVindexesBuilder(
          int index) {
        return getColumnVindexesFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public ColumnVindexOrBuilder getColumnVindexesOrBuilder(
          int index) {
        if (columnVindexesBuilder_ == null) {
          return columnVindexes_.get(index);  } else {
          return columnVindexesBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public java.util.List<? extends ColumnVindexOrBuilder>
           getColumnVindexesOrBuilderList() {
        if (columnVindexesBuilder_ != null) {
          return columnVindexesBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(columnVindexes_);
        }
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public ColumnVindex.Builder addColumnVindexesBuilder() {
        return getColumnVindexesFieldBuilder().addBuilder(
            ColumnVindex.getDefaultInstance());
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public ColumnVindex.Builder addColumnVindexesBuilder(
          int index) {
        return getColumnVindexesFieldBuilder().addBuilder(
            index, ColumnVindex.getDefaultInstance());
      }
      /**
       * <pre>
       * column_vindexes associates columns to vindexes.
       * </pre>
       *
       * <code>repeated .vschema.ColumnVindex column_vindexes = 2;</code>
       */
      public java.util.List<ColumnVindex.Builder>
           getColumnVindexesBuilderList() {
        return getColumnVindexesFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          ColumnVindex, ColumnVindex.Builder, ColumnVindexOrBuilder>
          getColumnVindexesFieldBuilder() {
        if (columnVindexesBuilder_ == null) {
          columnVindexesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              ColumnVindex, ColumnVindex.Builder, ColumnVindexOrBuilder>(
                  columnVindexes_,
                  ((bitField0_ & 0x00000002) == 0x00000002),
                  getParentForChildren(),
                  isClean());
          columnVindexes_ = null;
        }
        return columnVindexesBuilder_;
      }

      private AutoIncrement autoIncrement_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          AutoIncrement, AutoIncrement.Builder, AutoIncrementOrBuilder> autoIncrementBuilder_;
      /**
       * <pre>
       * auto_increment is specified if a column needs
       * to be associated with a sequence.
       * </pre>
       *
       * <code>.vschema.AutoIncrement auto_increment = 3;</code>
       */
      public boolean hasAutoIncrement() {
        return autoIncrementBuilder_ != null || autoIncrement_ != null;
      }
      /**
       * <pre>
       * auto_increment is specified if a column needs
       * to be associated with a sequence.
       * </pre>
       *
       * <code>.vschema.AutoIncrement auto_increment = 3;</code>
       */
      public AutoIncrement getAutoIncrement() {
        if (autoIncrementBuilder_ == null) {
          return autoIncrement_ == null ? AutoIncrement.getDefaultInstance() : autoIncrement_;
        } else {
          return autoIncrementBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * auto_increment is specified if a column needs
       * to be associated with a sequence.
       * </pre>
       *
       * <code>.vschema.AutoIncrement auto_increment = 3;</code>
       */
      public Builder setAutoIncrement(AutoIncrement value) {
        if (autoIncrementBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          autoIncrement_ = value;
          onChanged();
        } else {
          autoIncrementBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <pre>
       * auto_increment is specified if a column needs
       * to be associated with a sequence.
       * </pre>
       *
       * <code>.vschema.AutoIncrement auto_increment = 3;</code>
       */
      public Builder setAutoIncrement(
          AutoIncrement.Builder builderForValue) {
        if (autoIncrementBuilder_ == null) {
          autoIncrement_ = builderForValue.build();
          onChanged();
        } else {
          autoIncrementBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <pre>
       * auto_increment is specified if a column needs
       * to be associated with a sequence.
       * </pre>
       *
       * <code>.vschema.AutoIncrement auto_increment = 3;</code>
       */
      public Builder mergeAutoIncrement(AutoIncrement value) {
        if (autoIncrementBuilder_ == null) {
          if (autoIncrement_ != null) {
            autoIncrement_ =
              AutoIncrement.newBuilder(autoIncrement_).mergeFrom(value).buildPartial();
          } else {
            autoIncrement_ = value;
          }
          onChanged();
        } else {
          autoIncrementBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <pre>
       * auto_increment is specified if a column needs
       * to be associated with a sequence.
       * </pre>
       *
       * <code>.vschema.AutoIncrement auto_increment = 3;</code>
       */
      public Builder clearAutoIncrement() {
        if (autoIncrementBuilder_ == null) {
          autoIncrement_ = null;
          onChanged();
        } else {
          autoIncrement_ = null;
          autoIncrementBuilder_ = null;
        }

        return this;
      }
      /**
       * <pre>
       * auto_increment is specified if a column needs
       * to be associated with a sequence.
       * </pre>
       *
       * <code>.vschema.AutoIncrement auto_increment = 3;</code>
       */
      public AutoIncrement.Builder getAutoIncrementBuilder() {
        
        onChanged();
        return getAutoIncrementFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * auto_increment is specified if a column needs
       * to be associated with a sequence.
       * </pre>
       *
       * <code>.vschema.AutoIncrement auto_increment = 3;</code>
       */
      public AutoIncrementOrBuilder getAutoIncrementOrBuilder() {
        if (autoIncrementBuilder_ != null) {
          return autoIncrementBuilder_.getMessageOrBuilder();
        } else {
          return autoIncrement_ == null ?
              AutoIncrement.getDefaultInstance() : autoIncrement_;
        }
      }
      /**
       * <pre>
       * auto_increment is specified if a column needs
       * to be associated with a sequence.
       * </pre>
       *
       * <code>.vschema.AutoIncrement auto_increment = 3;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          AutoIncrement, AutoIncrement.Builder, AutoIncrementOrBuilder>
          getAutoIncrementFieldBuilder() {
        if (autoIncrementBuilder_ == null) {
          autoIncrementBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              AutoIncrement, AutoIncrement.Builder, AutoIncrementOrBuilder>(
                  getAutoIncrement(),
                  getParentForChildren(),
                  isClean());
          autoIncrement_ = null;
        }
        return autoIncrementBuilder_;
      }

      private java.util.List<Column> columns_ =
        java.util.Collections.emptyList();
      private void ensureColumnsIsMutable() {
        if (!((bitField0_ & 0x00000008) == 0x00000008)) {
          columns_ = new java.util.ArrayList<Column>(columns_);
          bitField0_ |= 0x00000008;
         }
      }

      private com.google.protobuf.RepeatedFieldBuilderV3<
          Column, Column.Builder, ColumnOrBuilder> columnsBuilder_;

      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public java.util.List<Column> getColumnsList() {
        if (columnsBuilder_ == null) {
          return java.util.Collections.unmodifiableList(columns_);
        } else {
          return columnsBuilder_.getMessageList();
        }
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public int getColumnsCount() {
        if (columnsBuilder_ == null) {
          return columns_.size();
        } else {
          return columnsBuilder_.getCount();
        }
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public Column getColumns(int index) {
        if (columnsBuilder_ == null) {
          return columns_.get(index);
        } else {
          return columnsBuilder_.getMessage(index);
        }
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public Builder setColumns(
          int index, Column value) {
        if (columnsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureColumnsIsMutable();
          columns_.set(index, value);
          onChanged();
        } else {
          columnsBuilder_.setMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public Builder setColumns(
          int index, Column.Builder builderForValue) {
        if (columnsBuilder_ == null) {
          ensureColumnsIsMutable();
          columns_.set(index, builderForValue.build());
          onChanged();
        } else {
          columnsBuilder_.setMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public Builder addColumns(Column value) {
        if (columnsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureColumnsIsMutable();
          columns_.add(value);
          onChanged();
        } else {
          columnsBuilder_.addMessage(value);
        }
        return this;
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public Builder addColumns(
          int index, Column value) {
        if (columnsBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          ensureColumnsIsMutable();
          columns_.add(index, value);
          onChanged();
        } else {
          columnsBuilder_.addMessage(index, value);
        }
        return this;
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public Builder addColumns(
          Column.Builder builderForValue) {
        if (columnsBuilder_ == null) {
          ensureColumnsIsMutable();
          columns_.add(builderForValue.build());
          onChanged();
        } else {
          columnsBuilder_.addMessage(builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public Builder addColumns(
          int index, Column.Builder builderForValue) {
        if (columnsBuilder_ == null) {
          ensureColumnsIsMutable();
          columns_.add(index, builderForValue.build());
          onChanged();
        } else {
          columnsBuilder_.addMessage(index, builderForValue.build());
        }
        return this;
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public Builder addAllColumns(
          Iterable<? extends Column> values) {
        if (columnsBuilder_ == null) {
          ensureColumnsIsMutable();
          com.google.protobuf.AbstractMessageLite.Builder.addAll(
              values, columns_);
          onChanged();
        } else {
          columnsBuilder_.addAllMessages(values);
        }
        return this;
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public Builder clearColumns() {
        if (columnsBuilder_ == null) {
          columns_ = java.util.Collections.emptyList();
          bitField0_ = (bitField0_ & ~0x00000008);
          onChanged();
        } else {
          columnsBuilder_.clear();
        }
        return this;
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public Builder removeColumns(int index) {
        if (columnsBuilder_ == null) {
          ensureColumnsIsMutable();
          columns_.remove(index);
          onChanged();
        } else {
          columnsBuilder_.remove(index);
        }
        return this;
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public Column.Builder getColumnsBuilder(
          int index) {
        return getColumnsFieldBuilder().getBuilder(index);
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public ColumnOrBuilder getColumnsOrBuilder(
          int index) {
        if (columnsBuilder_ == null) {
          return columns_.get(index);  } else {
          return columnsBuilder_.getMessageOrBuilder(index);
        }
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public java.util.List<? extends ColumnOrBuilder>
           getColumnsOrBuilderList() {
        if (columnsBuilder_ != null) {
          return columnsBuilder_.getMessageOrBuilderList();
        } else {
          return java.util.Collections.unmodifiableList(columns_);
        }
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public Column.Builder addColumnsBuilder() {
        return getColumnsFieldBuilder().addBuilder(
            Column.getDefaultInstance());
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public Column.Builder addColumnsBuilder(
          int index) {
        return getColumnsFieldBuilder().addBuilder(
            index, Column.getDefaultInstance());
      }
      /**
       * <pre>
       * columns lists the columns for the table.
       * </pre>
       *
       * <code>repeated .vschema.Column columns = 4;</code>
       */
      public java.util.List<Column.Builder>
           getColumnsBuilderList() {
        return getColumnsFieldBuilder().getBuilderList();
      }
      private com.google.protobuf.RepeatedFieldBuilderV3<
          Column, Column.Builder, ColumnOrBuilder>
          getColumnsFieldBuilder() {
        if (columnsBuilder_ == null) {
          columnsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<
              Column, Column.Builder, ColumnOrBuilder>(
                  columns_,
                  ((bitField0_ & 0x00000008) == 0x00000008),
                  getParentForChildren(),
                  isClean());
          columns_ = null;
        }
        return columnsBuilder_;
      }

      private Object pinned_ = "";
      /**
       * <pre>
       * pinned pins an unsharded table to a specific
       * shard, as dictated by the keyspace id.
       * The keyspace id is represented in hex form
       * like in keyranges.
       * </pre>
       *
       * <code>string pinned = 5;</code>
       */
      public String getPinned() {
        Object ref = pinned_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          pinned_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * pinned pins an unsharded table to a specific
       * shard, as dictated by the keyspace id.
       * The keyspace id is represented in hex form
       * like in keyranges.
       * </pre>
       *
       * <code>string pinned = 5;</code>
       */
      public com.google.protobuf.ByteString
          getPinnedBytes() {
        Object ref = pinned_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          pinned_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * pinned pins an unsharded table to a specific
       * shard, as dictated by the keyspace id.
       * The keyspace id is represented in hex form
       * like in keyranges.
       * </pre>
       *
       * <code>string pinned = 5;</code>
       */
      public Builder setPinned(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        pinned_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * pinned pins an unsharded table to a specific
       * shard, as dictated by the keyspace id.
       * The keyspace id is represented in hex form
       * like in keyranges.
       * </pre>
       *
       * <code>string pinned = 5;</code>
       */
      public Builder clearPinned() {
        
        pinned_ = getDefaultInstance().getPinned();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * pinned pins an unsharded table to a specific
       * shard, as dictated by the keyspace id.
       * The keyspace id is represented in hex form
       * like in keyranges.
       * </pre>
       *
       * <code>string pinned = 5;</code>
       */
      public Builder setPinnedBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        pinned_ = value;
        onChanged();
        return this;
      }

      private boolean columnListAuthoritative_ ;
      /**
       * <pre>
       * column_list_authoritative is set to true if columns is
       * an authoritative list for the table. This allows
       * us to expand 'select *' expressions.
       * </pre>
       *
       * <code>bool column_list_authoritative = 6;</code>
       */
      public boolean getColumnListAuthoritative() {
        return columnListAuthoritative_;
      }
      /**
       * <pre>
       * column_list_authoritative is set to true if columns is
       * an authoritative list for the table. This allows
       * us to expand 'select *' expressions.
       * </pre>
       *
       * <code>bool column_list_authoritative = 6;</code>
       */
      public Builder setColumnListAuthoritative(boolean value) {
        
        columnListAuthoritative_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * column_list_authoritative is set to true if columns is
       * an authoritative list for the table. This allows
       * us to expand 'select *' expressions.
       * </pre>
       *
       * <code>bool column_list_authoritative = 6;</code>
       */
      public Builder clearColumnListAuthoritative() {
        
        columnListAuthoritative_ = false;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:vschema.Table)
    }

    // @@protoc_insertion_point(class_scope:vschema.Table)
    private static final Table DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Table();
    }

    public static Table getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Table>
        PARSER = new com.google.protobuf.AbstractParser<Table>() {
      public Table parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Table(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Table> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<Table> getParserForType() {
      return PARSER;
    }

    public Table getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ColumnVindexOrBuilder extends
      // @@protoc_insertion_point(interface_extends:vschema.ColumnVindex)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Legacy implementation, moving forward all vindexes should define a list of columns.
     * </pre>
     *
     * <code>string column = 1;</code>
     */
    String getColumn();
    /**
     * <pre>
     * Legacy implementation, moving forward all vindexes should define a list of columns.
     * </pre>
     *
     * <code>string column = 1;</code>
     */
    com.google.protobuf.ByteString
        getColumnBytes();

    /**
     * <pre>
     * The name must match a vindex defined in Keyspace.
     * </pre>
     *
     * <code>string name = 2;</code>
     */
    String getName();
    /**
     * <pre>
     * The name must match a vindex defined in Keyspace.
     * </pre>
     *
     * <code>string name = 2;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * List of columns that define this Vindex
     * </pre>
     *
     * <code>repeated string columns = 3;</code>
     */
    java.util.List<String>
        getColumnsList();
    /**
     * <pre>
     * List of columns that define this Vindex
     * </pre>
     *
     * <code>repeated string columns = 3;</code>
     */
    int getColumnsCount();
    /**
     * <pre>
     * List of columns that define this Vindex
     * </pre>
     *
     * <code>repeated string columns = 3;</code>
     */
    String getColumns(int index);
    /**
     * <pre>
     * List of columns that define this Vindex
     * </pre>
     *
     * <code>repeated string columns = 3;</code>
     */
    com.google.protobuf.ByteString
        getColumnsBytes(int index);
  }
  /**
   * <pre>
   * ColumnVindex is used to associate a column to a vindex.
   * </pre>
   *
   * Protobuf type {@code vschema.ColumnVindex}
   */
  public  static final class ColumnVindex extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:vschema.ColumnVindex)
      ColumnVindexOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use ColumnVindex.newBuilder() to construct.
    private ColumnVindex(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private ColumnVindex() {
      column_ = "";
      name_ = "";
      columns_ = com.google.protobuf.LazyStringArrayList.EMPTY;
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private ColumnVindex(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              String s = input.readStringRequireUtf8();

              column_ = s;
              break;
            }
            case 18: {
              String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 26: {
              String s = input.readStringRequireUtf8();
              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
                columns_ = new com.google.protobuf.LazyStringArrayList();
                mutable_bitField0_ |= 0x00000004;
              }
              columns_.add(s);
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {
          columns_ = columns_.getUnmodifiableView();
        }
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Vschema.internal_static_vschema_ColumnVindex_descriptor;
    }

    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Vschema.internal_static_vschema_ColumnVindex_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              ColumnVindex.class, Builder.class);
    }

    private int bitField0_;
    public static final int COLUMN_FIELD_NUMBER = 1;
    private volatile Object column_;
    /**
     * <pre>
     * Legacy implementation, moving forward all vindexes should define a list of columns.
     * </pre>
     *
     * <code>string column = 1;</code>
     */
    public String getColumn() {
      Object ref = column_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        column_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * Legacy implementation, moving forward all vindexes should define a list of columns.
     * </pre>
     *
     * <code>string column = 1;</code>
     */
    public com.google.protobuf.ByteString
        getColumnBytes() {
      Object ref = column_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        column_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int NAME_FIELD_NUMBER = 2;
    private volatile Object name_;
    /**
     * <pre>
     * The name must match a vindex defined in Keyspace.
     * </pre>
     *
     * <code>string name = 2;</code>
     */
    public String getName() {
      Object ref = name_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The name must match a vindex defined in Keyspace.
     * </pre>
     *
     * <code>string name = 2;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      Object ref = name_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int COLUMNS_FIELD_NUMBER = 3;
    private com.google.protobuf.LazyStringList columns_;
    /**
     * <pre>
     * List of columns that define this Vindex
     * </pre>
     *
     * <code>repeated string columns = 3;</code>
     */
    public com.google.protobuf.ProtocolStringList
        getColumnsList() {
      return columns_;
    }
    /**
     * <pre>
     * List of columns that define this Vindex
     * </pre>
     *
     * <code>repeated string columns = 3;</code>
     */
    public int getColumnsCount() {
      return columns_.size();
    }
    /**
     * <pre>
     * List of columns that define this Vindex
     * </pre>
     *
     * <code>repeated string columns = 3;</code>
     */
    public String getColumns(int index) {
      return columns_.get(index);
    }
    /**
     * <pre>
     * List of columns that define this Vindex
     * </pre>
     *
     * <code>repeated string columns = 3;</code>
     */
    public com.google.protobuf.ByteString
        getColumnsBytes(int index) {
      return columns_.getByteString(index);
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getColumnBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, column_);
      }
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, name_);
      }
      for (int i = 0; i < columns_.size(); i++) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 3, columns_.getRaw(i));
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getColumnBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, column_);
      }
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, name_);
      }
      {
        int dataSize = 0;
        for (int i = 0; i < columns_.size(); i++) {
          dataSize += computeStringSizeNoTag(columns_.getRaw(i));
        }
        size += dataSize;
        size += 1 * getColumnsList().size();
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof ColumnVindex)) {
        return super.equals(obj);
      }
      ColumnVindex other = (ColumnVindex) obj;

      boolean result = true;
      result = result && getColumn()
          .equals(other.getColumn());
      result = result && getName()
          .equals(other.getName());
      result = result && getColumnsList()
          .equals(other.getColumnsList());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + COLUMN_FIELD_NUMBER;
      hash = (53 * hash) + getColumn().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      if (getColumnsCount() > 0) {
        hash = (37 * hash) + COLUMNS_FIELD_NUMBER;
        hash = (53 * hash) + getColumnsList().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static ColumnVindex parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ColumnVindex parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ColumnVindex parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ColumnVindex parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ColumnVindex parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static ColumnVindex parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static ColumnVindex parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ColumnVindex parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static ColumnVindex parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static ColumnVindex parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static ColumnVindex parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static ColumnVindex parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(ColumnVindex prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * ColumnVindex is used to associate a column to a vindex.
     * </pre>
     *
     * Protobuf type {@code vschema.ColumnVindex}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:vschema.ColumnVindex)
        ColumnVindexOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Vschema.internal_static_vschema_ColumnVindex_descriptor;
      }

      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Vschema.internal_static_vschema_ColumnVindex_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                ColumnVindex.class, Builder.class);
      }

      // Construct using vschema.Vschema.ColumnVindex.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        column_ = "";

        name_ = "";

        columns_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Vschema.internal_static_vschema_ColumnVindex_descriptor;
      }

      public ColumnVindex getDefaultInstanceForType() {
        return ColumnVindex.getDefaultInstance();
      }

      public ColumnVindex build() {
        ColumnVindex result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public ColumnVindex buildPartial() {
        ColumnVindex result = new ColumnVindex(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.column_ = column_;
        result.name_ = name_;
        if (((bitField0_ & 0x00000004) == 0x00000004)) {
          columns_ = columns_.getUnmodifiableView();
          bitField0_ = (bitField0_ & ~0x00000004);
        }
        result.columns_ = columns_;
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof ColumnVindex) {
          return mergeFrom((ColumnVindex)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(ColumnVindex other) {
        if (other == ColumnVindex.getDefaultInstance()) return this;
        if (!other.getColumn().isEmpty()) {
          column_ = other.column_;
          onChanged();
        }
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (!other.columns_.isEmpty()) {
          if (columns_.isEmpty()) {
            columns_ = other.columns_;
            bitField0_ = (bitField0_ & ~0x00000004);
          } else {
            ensureColumnsIsMutable();
            columns_.addAll(other.columns_);
          }
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        ColumnVindex parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (ColumnVindex) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private Object column_ = "";
      /**
       * <pre>
       * Legacy implementation, moving forward all vindexes should define a list of columns.
       * </pre>
       *
       * <code>string column = 1;</code>
       */
      public String getColumn() {
        Object ref = column_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          column_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * Legacy implementation, moving forward all vindexes should define a list of columns.
       * </pre>
       *
       * <code>string column = 1;</code>
       */
      public com.google.protobuf.ByteString
          getColumnBytes() {
        Object ref = column_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          column_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Legacy implementation, moving forward all vindexes should define a list of columns.
       * </pre>
       *
       * <code>string column = 1;</code>
       */
      public Builder setColumn(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        column_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Legacy implementation, moving forward all vindexes should define a list of columns.
       * </pre>
       *
       * <code>string column = 1;</code>
       */
      public Builder clearColumn() {
        
        column_ = getDefaultInstance().getColumn();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Legacy implementation, moving forward all vindexes should define a list of columns.
       * </pre>
       *
       * <code>string column = 1;</code>
       */
      public Builder setColumnBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        column_ = value;
        onChanged();
        return this;
      }

      private Object name_ = "";
      /**
       * <pre>
       * The name must match a vindex defined in Keyspace.
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public String getName() {
        Object ref = name_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * The name must match a vindex defined in Keyspace.
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The name must match a vindex defined in Keyspace.
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public Builder setName(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name must match a vindex defined in Keyspace.
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The name must match a vindex defined in Keyspace.
       * </pre>
       *
       * <code>string name = 2;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private com.google.protobuf.LazyStringList columns_ = com.google.protobuf.LazyStringArrayList.EMPTY;
      private void ensureColumnsIsMutable() {
        if (!((bitField0_ & 0x00000004) == 0x00000004)) {
          columns_ = new com.google.protobuf.LazyStringArrayList(columns_);
          bitField0_ |= 0x00000004;
         }
      }
      /**
       * <pre>
       * List of columns that define this Vindex
       * </pre>
       *
       * <code>repeated string columns = 3;</code>
       */
      public com.google.protobuf.ProtocolStringList
          getColumnsList() {
        return columns_.getUnmodifiableView();
      }
      /**
       * <pre>
       * List of columns that define this Vindex
       * </pre>
       *
       * <code>repeated string columns = 3;</code>
       */
      public int getColumnsCount() {
        return columns_.size();
      }
      /**
       * <pre>
       * List of columns that define this Vindex
       * </pre>
       *
       * <code>repeated string columns = 3;</code>
       */
      public String getColumns(int index) {
        return columns_.get(index);
      }
      /**
       * <pre>
       * List of columns that define this Vindex
       * </pre>
       *
       * <code>repeated string columns = 3;</code>
       */
      public com.google.protobuf.ByteString
          getColumnsBytes(int index) {
        return columns_.getByteString(index);
      }
      /**
       * <pre>
       * List of columns that define this Vindex
       * </pre>
       *
       * <code>repeated string columns = 3;</code>
       */
      public Builder setColumns(
          int index, String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureColumnsIsMutable();
        columns_.set(index, value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * List of columns that define this Vindex
       * </pre>
       *
       * <code>repeated string columns = 3;</code>
       */
      public Builder addColumns(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  ensureColumnsIsMutable();
        columns_.add(value);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * List of columns that define this Vindex
       * </pre>
       *
       * <code>repeated string columns = 3;</code>
       */
      public Builder addAllColumns(
          Iterable<String> values) {
        ensureColumnsIsMutable();
        com.google.protobuf.AbstractMessageLite.Builder.addAll(
            values, columns_);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * List of columns that define this Vindex
       * </pre>
       *
       * <code>repeated string columns = 3;</code>
       */
      public Builder clearColumns() {
        columns_ = com.google.protobuf.LazyStringArrayList.EMPTY;
        bitField0_ = (bitField0_ & ~0x00000004);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * List of columns that define this Vindex
       * </pre>
       *
       * <code>repeated string columns = 3;</code>
       */
      public Builder addColumnsBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        ensureColumnsIsMutable();
        columns_.add(value);
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:vschema.ColumnVindex)
    }

    // @@protoc_insertion_point(class_scope:vschema.ColumnVindex)
    private static final ColumnVindex DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new ColumnVindex();
    }

    public static ColumnVindex getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<ColumnVindex>
        PARSER = new com.google.protobuf.AbstractParser<ColumnVindex>() {
      public ColumnVindex parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new ColumnVindex(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<ColumnVindex> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<ColumnVindex> getParserForType() {
      return PARSER;
    }

    public ColumnVindex getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface AutoIncrementOrBuilder extends
      // @@protoc_insertion_point(interface_extends:vschema.AutoIncrement)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>string column = 1;</code>
     */
    String getColumn();
    /**
     * <code>string column = 1;</code>
     */
    com.google.protobuf.ByteString
        getColumnBytes();

    /**
     * <pre>
     * The sequence must match a table of type SEQUENCE.
     * </pre>
     *
     * <code>string sequence = 2;</code>
     */
    String getSequence();
    /**
     * <pre>
     * The sequence must match a table of type SEQUENCE.
     * </pre>
     *
     * <code>string sequence = 2;</code>
     */
    com.google.protobuf.ByteString
        getSequenceBytes();
  }
  /**
   * <pre>
   * Autoincrement is used to designate a column as auto-inc.
   * </pre>
   *
   * Protobuf type {@code vschema.AutoIncrement}
   */
  public  static final class AutoIncrement extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:vschema.AutoIncrement)
      AutoIncrementOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use AutoIncrement.newBuilder() to construct.
    private AutoIncrement(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private AutoIncrement() {
      column_ = "";
      sequence_ = "";
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private AutoIncrement(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              String s = input.readStringRequireUtf8();

              column_ = s;
              break;
            }
            case 18: {
              String s = input.readStringRequireUtf8();

              sequence_ = s;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Vschema.internal_static_vschema_AutoIncrement_descriptor;
    }

    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Vschema.internal_static_vschema_AutoIncrement_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              AutoIncrement.class, Builder.class);
    }

    public static final int COLUMN_FIELD_NUMBER = 1;
    private volatile Object column_;
    /**
     * <code>string column = 1;</code>
     */
    public String getColumn() {
      Object ref = column_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        column_ = s;
        return s;
      }
    }
    /**
     * <code>string column = 1;</code>
     */
    public com.google.protobuf.ByteString
        getColumnBytes() {
      Object ref = column_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        column_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int SEQUENCE_FIELD_NUMBER = 2;
    private volatile Object sequence_;
    /**
     * <pre>
     * The sequence must match a table of type SEQUENCE.
     * </pre>
     *
     * <code>string sequence = 2;</code>
     */
    public String getSequence() {
      Object ref = sequence_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        sequence_ = s;
        return s;
      }
    }
    /**
     * <pre>
     * The sequence must match a table of type SEQUENCE.
     * </pre>
     *
     * <code>string sequence = 2;</code>
     */
    public com.google.protobuf.ByteString
        getSequenceBytes() {
      Object ref = sequence_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        sequence_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getColumnBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, column_);
      }
      if (!getSequenceBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 2, sequence_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getColumnBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, column_);
      }
      if (!getSequenceBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(2, sequence_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof AutoIncrement)) {
        return super.equals(obj);
      }
      AutoIncrement other = (AutoIncrement) obj;

      boolean result = true;
      result = result && getColumn()
          .equals(other.getColumn());
      result = result && getSequence()
          .equals(other.getSequence());
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + COLUMN_FIELD_NUMBER;
      hash = (53 * hash) + getColumn().hashCode();
      hash = (37 * hash) + SEQUENCE_FIELD_NUMBER;
      hash = (53 * hash) + getSequence().hashCode();
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static AutoIncrement parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static AutoIncrement parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static AutoIncrement parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static AutoIncrement parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static AutoIncrement parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static AutoIncrement parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static AutoIncrement parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static AutoIncrement parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static AutoIncrement parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static AutoIncrement parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static AutoIncrement parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static AutoIncrement parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(AutoIncrement prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Autoincrement is used to designate a column as auto-inc.
     * </pre>
     *
     * Protobuf type {@code vschema.AutoIncrement}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:vschema.AutoIncrement)
        AutoIncrementOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Vschema.internal_static_vschema_AutoIncrement_descriptor;
      }

      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Vschema.internal_static_vschema_AutoIncrement_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                AutoIncrement.class, Builder.class);
      }

      // Construct using vschema.Vschema.AutoIncrement.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        column_ = "";

        sequence_ = "";

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Vschema.internal_static_vschema_AutoIncrement_descriptor;
      }

      public AutoIncrement getDefaultInstanceForType() {
        return AutoIncrement.getDefaultInstance();
      }

      public AutoIncrement build() {
        AutoIncrement result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public AutoIncrement buildPartial() {
        AutoIncrement result = new AutoIncrement(this);
        result.column_ = column_;
        result.sequence_ = sequence_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof AutoIncrement) {
          return mergeFrom((AutoIncrement)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(AutoIncrement other) {
        if (other == AutoIncrement.getDefaultInstance()) return this;
        if (!other.getColumn().isEmpty()) {
          column_ = other.column_;
          onChanged();
        }
        if (!other.getSequence().isEmpty()) {
          sequence_ = other.sequence_;
          onChanged();
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        AutoIncrement parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (AutoIncrement) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private Object column_ = "";
      /**
       * <code>string column = 1;</code>
       */
      public String getColumn() {
        Object ref = column_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          column_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <code>string column = 1;</code>
       */
      public com.google.protobuf.ByteString
          getColumnBytes() {
        Object ref = column_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          column_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string column = 1;</code>
       */
      public Builder setColumn(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        column_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string column = 1;</code>
       */
      public Builder clearColumn() {
        
        column_ = getDefaultInstance().getColumn();
        onChanged();
        return this;
      }
      /**
       * <code>string column = 1;</code>
       */
      public Builder setColumnBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        column_ = value;
        onChanged();
        return this;
      }

      private Object sequence_ = "";
      /**
       * <pre>
       * The sequence must match a table of type SEQUENCE.
       * </pre>
       *
       * <code>string sequence = 2;</code>
       */
      public String getSequence() {
        Object ref = sequence_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          sequence_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <pre>
       * The sequence must match a table of type SEQUENCE.
       * </pre>
       *
       * <code>string sequence = 2;</code>
       */
      public com.google.protobuf.ByteString
          getSequenceBytes() {
        Object ref = sequence_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          sequence_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * The sequence must match a table of type SEQUENCE.
       * </pre>
       *
       * <code>string sequence = 2;</code>
       */
      public Builder setSequence(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        sequence_ = value;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The sequence must match a table of type SEQUENCE.
       * </pre>
       *
       * <code>string sequence = 2;</code>
       */
      public Builder clearSequence() {
        
        sequence_ = getDefaultInstance().getSequence();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The sequence must match a table of type SEQUENCE.
       * </pre>
       *
       * <code>string sequence = 2;</code>
       */
      public Builder setSequenceBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        sequence_ = value;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:vschema.AutoIncrement)
    }

    // @@protoc_insertion_point(class_scope:vschema.AutoIncrement)
    private static final AutoIncrement DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new AutoIncrement();
    }

    public static AutoIncrement getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<AutoIncrement>
        PARSER = new com.google.protobuf.AbstractParser<AutoIncrement>() {
      public AutoIncrement parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new AutoIncrement(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<AutoIncrement> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<AutoIncrement> getParserForType() {
      return PARSER;
    }

    public AutoIncrement getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface ColumnOrBuilder extends
      // @@protoc_insertion_point(interface_extends:vschema.Column)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <code>string name = 1;</code>
     */
    String getName();
    /**
     * <code>string name = 1;</code>
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <code>.query.Type type = 2;</code>
     */
    int getTypeValue();
    /**
     * <code>.query.Type type = 2;</code>
     */
    io.vitess.proto.Query.Type getType();
  }
  /**
   * <pre>
   * Column describes a column.
   * </pre>
   *
   * Protobuf type {@code vschema.Column}
   */
  public  static final class Column extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:vschema.Column)
      ColumnOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use Column.newBuilder() to construct.
    private Column(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private Column() {
      name_ = "";
      type_ = 0;
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private Column(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              String s = input.readStringRequireUtf8();

              name_ = s;
              break;
            }
            case 16: {
              int rawValue = input.readEnum();

              type_ = rawValue;
              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Vschema.internal_static_vschema_Column_descriptor;
    }

    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Vschema.internal_static_vschema_Column_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              Column.class, Builder.class);
    }

    public static final int NAME_FIELD_NUMBER = 1;
    private volatile Object name_;
    /**
     * <code>string name = 1;</code>
     */
    public String getName() {
      Object ref = name_;
      if (ref instanceof String) {
        return (String) ref;
      } else {
        com.google.protobuf.ByteString bs = 
            (com.google.protobuf.ByteString) ref;
        String s = bs.toStringUtf8();
        name_ = s;
        return s;
      }
    }
    /**
     * <code>string name = 1;</code>
     */
    public com.google.protobuf.ByteString
        getNameBytes() {
      Object ref = name_;
      if (ref instanceof String) {
        com.google.protobuf.ByteString b = 
            com.google.protobuf.ByteString.copyFromUtf8(
                (String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TYPE_FIELD_NUMBER = 2;
    private int type_;
    /**
     * <code>.query.Type type = 2;</code>
     */
    public int getTypeValue() {
      return type_;
    }
    /**
     * <code>.query.Type type = 2;</code>
     */
    public io.vitess.proto.Query.Type getType() {
      io.vitess.proto.Query.Type result = io.vitess.proto.Query.Type.valueOf(type_);
      return result == null ? io.vitess.proto.Query.Type.UNRECOGNIZED : result;
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (!getNameBytes().isEmpty()) {
        com.google.protobuf.GeneratedMessageV3.writeString(output, 1, name_);
      }
      if (type_ != io.vitess.proto.Query.Type.NULL_TYPE.getNumber()) {
        output.writeEnum(2, type_);
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (!getNameBytes().isEmpty()) {
        size += com.google.protobuf.GeneratedMessageV3.computeStringSize(1, name_);
      }
      if (type_ != io.vitess.proto.Query.Type.NULL_TYPE.getNumber()) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(2, type_);
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof Column)) {
        return super.equals(obj);
      }
      Column other = (Column) obj;

      boolean result = true;
      result = result && getName()
          .equals(other.getName());
      result = result && type_ == other.type_;
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      hash = (37 * hash) + NAME_FIELD_NUMBER;
      hash = (53 * hash) + getName().hashCode();
      hash = (37 * hash) + TYPE_FIELD_NUMBER;
      hash = (53 * hash) + type_;
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static Column parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Column parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Column parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Column parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Column parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static Column parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static Column parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Column parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static Column parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static Column parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static Column parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static Column parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(Column prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * Column describes a column.
     * </pre>
     *
     * Protobuf type {@code vschema.Column}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:vschema.Column)
        ColumnOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Vschema.internal_static_vschema_Column_descriptor;
      }

      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Vschema.internal_static_vschema_Column_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                Column.class, Builder.class);
      }

      // Construct using vschema.Vschema.Column.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        name_ = "";

        type_ = 0;

        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Vschema.internal_static_vschema_Column_descriptor;
      }

      public Column getDefaultInstanceForType() {
        return Column.getDefaultInstance();
      }

      public Column build() {
        Column result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public Column buildPartial() {
        Column result = new Column(this);
        result.name_ = name_;
        result.type_ = type_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof Column) {
          return mergeFrom((Column)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(Column other) {
        if (other == Column.getDefaultInstance()) return this;
        if (!other.getName().isEmpty()) {
          name_ = other.name_;
          onChanged();
        }
        if (other.type_ != 0) {
          setTypeValue(other.getTypeValue());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        Column parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (Column) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }

      private Object name_ = "";
      /**
       * <code>string name = 1;</code>
       */
      public String getName() {
        Object ref = name_;
        if (!(ref instanceof String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          String s = bs.toStringUtf8();
          name_ = s;
          return s;
        } else {
          return (String) ref;
        }
      }
      /**
       * <code>string name = 1;</code>
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b = 
              com.google.protobuf.ByteString.copyFromUtf8(
                  (String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <code>string name = 1;</code>
       */
      public Builder setName(
          String value) {
        if (value == null) {
    throw new NullPointerException();
  }
  
        name_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>string name = 1;</code>
       */
      public Builder clearName() {
        
        name_ = getDefaultInstance().getName();
        onChanged();
        return this;
      }
      /**
       * <code>string name = 1;</code>
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) {
    throw new NullPointerException();
  }
  checkByteStringIsUtf8(value);
        
        name_ = value;
        onChanged();
        return this;
      }

      private int type_ = 0;
      /**
       * <code>.query.Type type = 2;</code>
       */
      public int getTypeValue() {
        return type_;
      }
      /**
       * <code>.query.Type type = 2;</code>
       */
      public Builder setTypeValue(int value) {
        type_ = value;
        onChanged();
        return this;
      }
      /**
       * <code>.query.Type type = 2;</code>
       */
      public io.vitess.proto.Query.Type getType() {
        io.vitess.proto.Query.Type result = io.vitess.proto.Query.Type.valueOf(type_);
        return result == null ? io.vitess.proto.Query.Type.UNRECOGNIZED : result;
      }
      /**
       * <code>.query.Type type = 2;</code>
       */
      public Builder setType(io.vitess.proto.Query.Type value) {
        if (value == null) {
          throw new NullPointerException();
        }
        
        type_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <code>.query.Type type = 2;</code>
       */
      public Builder clearType() {
        
        type_ = 0;
        onChanged();
        return this;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:vschema.Column)
    }

    // @@protoc_insertion_point(class_scope:vschema.Column)
    private static final Column DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new Column();
    }

    public static Column getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<Column>
        PARSER = new com.google.protobuf.AbstractParser<Column>() {
      public Column parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new Column(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<Column> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<Column> getParserForType() {
      return PARSER;
    }

    public Column getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  public interface SrvVSchemaOrBuilder extends
      // @@protoc_insertion_point(interface_extends:vschema.SrvVSchema)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * keyspaces is a map of keyspace name -&gt; Keyspace object.
     * </pre>
     *
     * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
     */
    int getKeyspacesCount();
    /**
     * <pre>
     * keyspaces is a map of keyspace name -&gt; Keyspace object.
     * </pre>
     *
     * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
     */
    boolean containsKeyspaces(
        String key);
    /**
     * Use {@link #getKeyspacesMap()} instead.
     */
    @Deprecated
    java.util.Map<String, Keyspace>
    getKeyspaces();
    /**
     * <pre>
     * keyspaces is a map of keyspace name -&gt; Keyspace object.
     * </pre>
     *
     * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
     */
    java.util.Map<String, Keyspace>
    getKeyspacesMap();
    /**
     * <pre>
     * keyspaces is a map of keyspace name -&gt; Keyspace object.
     * </pre>
     *
     * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
     */

    Keyspace getKeyspacesOrDefault(
        String key,
        Keyspace defaultValue);
    /**
     * <pre>
     * keyspaces is a map of keyspace name -&gt; Keyspace object.
     * </pre>
     *
     * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
     */

    Keyspace getKeyspacesOrThrow(
        String key);

    /**
     * <code>.vschema.RoutingRules routing_rules = 2;</code>
     */
    boolean hasRoutingRules();
    /**
     * <code>.vschema.RoutingRules routing_rules = 2;</code>
     */
    RoutingRules getRoutingRules();
    /**
     * <code>.vschema.RoutingRules routing_rules = 2;</code>
     */
    RoutingRulesOrBuilder getRoutingRulesOrBuilder();
  }
  /**
   * <pre>
   * SrvVSchema is the roll-up of all the Keyspace schema for a cell.
   * </pre>
   *
   * Protobuf type {@code vschema.SrvVSchema}
   */
  public  static final class SrvVSchema extends
      com.google.protobuf.GeneratedMessageV3 implements
      // @@protoc_insertion_point(message_implements:vschema.SrvVSchema)
      SrvVSchemaOrBuilder {
  private static final long serialVersionUID = 0L;
    // Use SrvVSchema.newBuilder() to construct.
    private SrvVSchema(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
      super(builder);
    }
    private SrvVSchema() {
    }

    @Override
    public final com.google.protobuf.UnknownFieldSet
    getUnknownFields() {
      return this.unknownFields;
    }
    private SrvVSchema(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      this();
      if (extensionRegistry == null) {
        throw new NullPointerException();
      }
      int mutable_bitField0_ = 0;
      com.google.protobuf.UnknownFieldSet.Builder unknownFields =
          com.google.protobuf.UnknownFieldSet.newBuilder();
      try {
        boolean done = false;
        while (!done) {
          int tag = input.readTag();
          switch (tag) {
            case 0:
              done = true;
              break;
            default: {
              if (!parseUnknownFieldProto3(
                  input, unknownFields, extensionRegistry, tag)) {
                done = true;
              }
              break;
            }
            case 10: {
              if (!((mutable_bitField0_ & 0x00000001) == 0x00000001)) {
                keyspaces_ = com.google.protobuf.MapField.newMapField(
                    KeyspacesDefaultEntryHolder.defaultEntry);
                mutable_bitField0_ |= 0x00000001;
              }
              com.google.protobuf.MapEntry<String, Keyspace>
              keyspaces__ = input.readMessage(
                  KeyspacesDefaultEntryHolder.defaultEntry.getParserForType(), extensionRegistry);
              keyspaces_.getMutableMap().put(
                  keyspaces__.getKey(), keyspaces__.getValue());
              break;
            }
            case 18: {
              RoutingRules.Builder subBuilder = null;
              if (routingRules_ != null) {
                subBuilder = routingRules_.toBuilder();
              }
              routingRules_ = input.readMessage(RoutingRules.parser(), extensionRegistry);
              if (subBuilder != null) {
                subBuilder.mergeFrom(routingRules_);
                routingRules_ = subBuilder.buildPartial();
              }

              break;
            }
          }
        }
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        throw e.setUnfinishedMessage(this);
      } catch (java.io.IOException e) {
        throw new com.google.protobuf.InvalidProtocolBufferException(
            e).setUnfinishedMessage(this);
      } finally {
        this.unknownFields = unknownFields.build();
        makeExtensionsImmutable();
      }
    }
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return Vschema.internal_static_vschema_SrvVSchema_descriptor;
    }

    @SuppressWarnings({"rawtypes"})
    protected com.google.protobuf.MapField internalGetMapField(
        int number) {
      switch (number) {
        case 1:
          return internalGetKeyspaces();
        default:
          throw new RuntimeException(
              "Invalid map field number: " + number);
      }
    }
    protected FieldAccessorTable
        internalGetFieldAccessorTable() {
      return Vschema.internal_static_vschema_SrvVSchema_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              SrvVSchema.class, Builder.class);
    }

    private int bitField0_;
    public static final int KEYSPACES_FIELD_NUMBER = 1;
    private static final class KeyspacesDefaultEntryHolder {
      static final com.google.protobuf.MapEntry<
          String, Keyspace> defaultEntry =
              com.google.protobuf.MapEntry
              .<String, Keyspace>newDefaultInstance(
                  Vschema.internal_static_vschema_SrvVSchema_KeyspacesEntry_descriptor,
                  com.google.protobuf.WireFormat.FieldType.STRING,
                  "",
                  com.google.protobuf.WireFormat.FieldType.MESSAGE,
                  Keyspace.getDefaultInstance());
    }
    private com.google.protobuf.MapField<
        String, Keyspace> keyspaces_;
    private com.google.protobuf.MapField<String, Keyspace>
    internalGetKeyspaces() {
      if (keyspaces_ == null) {
        return com.google.protobuf.MapField.emptyMapField(
            KeyspacesDefaultEntryHolder.defaultEntry);
      }
      return keyspaces_;
    }

    public int getKeyspacesCount() {
      return internalGetKeyspaces().getMap().size();
    }
    /**
     * <pre>
     * keyspaces is a map of keyspace name -&gt; Keyspace object.
     * </pre>
     *
     * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
     */

    public boolean containsKeyspaces(
        String key) {
      if (key == null) { throw new NullPointerException(); }
      return internalGetKeyspaces().getMap().containsKey(key);
    }
    /**
     * Use {@link #getKeyspacesMap()} instead.
     */
    @Deprecated
    public java.util.Map<String, Keyspace> getKeyspaces() {
      return getKeyspacesMap();
    }
    /**
     * <pre>
     * keyspaces is a map of keyspace name -&gt; Keyspace object.
     * </pre>
     *
     * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
     */

    public java.util.Map<String, Keyspace> getKeyspacesMap() {
      return internalGetKeyspaces().getMap();
    }
    /**
     * <pre>
     * keyspaces is a map of keyspace name -&gt; Keyspace object.
     * </pre>
     *
     * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
     */

    public Keyspace getKeyspacesOrDefault(
        String key,
        Keyspace defaultValue) {
      if (key == null) { throw new NullPointerException(); }
      java.util.Map<String, Keyspace> map =
          internalGetKeyspaces().getMap();
      return map.containsKey(key) ? map.get(key) : defaultValue;
    }
    /**
     * <pre>
     * keyspaces is a map of keyspace name -&gt; Keyspace object.
     * </pre>
     *
     * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
     */

    public Keyspace getKeyspacesOrThrow(
        String key) {
      if (key == null) { throw new NullPointerException(); }
      java.util.Map<String, Keyspace> map =
          internalGetKeyspaces().getMap();
      if (!map.containsKey(key)) {
        throw new IllegalArgumentException();
      }
      return map.get(key);
    }

    public static final int ROUTING_RULES_FIELD_NUMBER = 2;
    private RoutingRules routingRules_;
    /**
     * <code>.vschema.RoutingRules routing_rules = 2;</code>
     */
    public boolean hasRoutingRules() {
      return routingRules_ != null;
    }
    /**
     * <code>.vschema.RoutingRules routing_rules = 2;</code>
     */
    public RoutingRules getRoutingRules() {
      return routingRules_ == null ? RoutingRules.getDefaultInstance() : routingRules_;
    }
    /**
     * <code>.vschema.RoutingRules routing_rules = 2;</code>
     */
    public RoutingRulesOrBuilder getRoutingRulesOrBuilder() {
      return getRoutingRules();
    }

    private byte memoizedIsInitialized = -1;
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      com.google.protobuf.GeneratedMessageV3
        .serializeStringMapTo(
          output,
          internalGetKeyspaces(),
          KeyspacesDefaultEntryHolder.defaultEntry,
          1);
      if (routingRules_ != null) {
        output.writeMessage(2, getRoutingRules());
      }
      unknownFields.writeTo(output);
    }

    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      for (java.util.Map.Entry<String, Keyspace> entry
           : internalGetKeyspaces().getMap().entrySet()) {
        com.google.protobuf.MapEntry<String, Keyspace>
        keyspaces__ = KeyspacesDefaultEntryHolder.defaultEntry.newBuilderForType()
            .setKey(entry.getKey())
            .setValue(entry.getValue())
            .build();
        size += com.google.protobuf.CodedOutputStream
            .computeMessageSize(1, keyspaces__);
      }
      if (routingRules_ != null) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(2, getRoutingRules());
      }
      size += unknownFields.getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @Override
    public boolean equals(final Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof SrvVSchema)) {
        return super.equals(obj);
      }
      SrvVSchema other = (SrvVSchema) obj;

      boolean result = true;
      result = result && internalGetKeyspaces().equals(
          other.internalGetKeyspaces());
      result = result && (hasRoutingRules() == other.hasRoutingRules());
      if (hasRoutingRules()) {
        result = result && getRoutingRules()
            .equals(other.getRoutingRules());
      }
      result = result && unknownFields.equals(other.unknownFields);
      return result;
    }

    @Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (!internalGetKeyspaces().getMap().isEmpty()) {
        hash = (37 * hash) + KEYSPACES_FIELD_NUMBER;
        hash = (53 * hash) + internalGetKeyspaces().hashCode();
      }
      if (hasRoutingRules()) {
        hash = (37 * hash) + ROUTING_RULES_FIELD_NUMBER;
        hash = (53 * hash) + getRoutingRules().hashCode();
      }
      hash = (29 * hash) + unknownFields.hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static SrvVSchema parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static SrvVSchema parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static SrvVSchema parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static SrvVSchema parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static SrvVSchema parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static SrvVSchema parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static SrvVSchema parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static SrvVSchema parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }
    public static SrvVSchema parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input);
    }
    public static SrvVSchema parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static SrvVSchema parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input);
    }
    public static SrvVSchema parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessageV3
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(SrvVSchema prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @Override
    protected Builder newBuilderForType(
        BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * SrvVSchema is the roll-up of all the Keyspace schema for a cell.
     * </pre>
     *
     * Protobuf type {@code vschema.SrvVSchema}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:vschema.SrvVSchema)
        SrvVSchemaOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return Vschema.internal_static_vschema_SrvVSchema_descriptor;
      }

      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetKeyspaces();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      @SuppressWarnings({"rawtypes"})
      protected com.google.protobuf.MapField internalGetMutableMapField(
          int number) {
        switch (number) {
          case 1:
            return internalGetMutableKeyspaces();
          default:
            throw new RuntimeException(
                "Invalid map field number: " + number);
        }
      }
      protected FieldAccessorTable
          internalGetFieldAccessorTable() {
        return Vschema.internal_static_vschema_SrvVSchema_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                SrvVSchema.class, Builder.class);
      }

      // Construct using vschema.Vschema.SrvVSchema.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessageV3
                .alwaysUseFieldBuilders) {
        }
      }
      public Builder clear() {
        super.clear();
        internalGetMutableKeyspaces().clear();
        if (routingRulesBuilder_ == null) {
          routingRules_ = null;
        } else {
          routingRules_ = null;
          routingRulesBuilder_ = null;
        }
        return this;
      }

      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return Vschema.internal_static_vschema_SrvVSchema_descriptor;
      }

      public SrvVSchema getDefaultInstanceForType() {
        return SrvVSchema.getDefaultInstance();
      }

      public SrvVSchema build() {
        SrvVSchema result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      public SrvVSchema buildPartial() {
        SrvVSchema result = new SrvVSchema(this);
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        result.keyspaces_ = internalGetKeyspaces();
        result.keyspaces_.makeImmutable();
        if (routingRulesBuilder_ == null) {
          result.routingRules_ = routingRules_;
        } else {
          result.routingRules_ = routingRulesBuilder_.build();
        }
        result.bitField0_ = to_bitField0_;
        onBuilt();
        return result;
      }

      public Builder clone() {
        return (Builder) super.clone();
      }
      public Builder setField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.setField(field, value);
      }
      public Builder clearField(
          com.google.protobuf.Descriptors.FieldDescriptor field) {
        return (Builder) super.clearField(field);
      }
      public Builder clearOneof(
          com.google.protobuf.Descriptors.OneofDescriptor oneof) {
        return (Builder) super.clearOneof(oneof);
      }
      public Builder setRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          int index, Object value) {
        return (Builder) super.setRepeatedField(field, index, value);
      }
      public Builder addRepeatedField(
          com.google.protobuf.Descriptors.FieldDescriptor field,
          Object value) {
        return (Builder) super.addRepeatedField(field, value);
      }
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof SrvVSchema) {
          return mergeFrom((SrvVSchema)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(SrvVSchema other) {
        if (other == SrvVSchema.getDefaultInstance()) return this;
        internalGetMutableKeyspaces().mergeFrom(
            other.internalGetKeyspaces());
        if (other.hasRoutingRules()) {
          mergeRoutingRules(other.getRoutingRules());
        }
        this.mergeUnknownFields(other.unknownFields);
        onChanged();
        return this;
      }

      public final boolean isInitialized() {
        return true;
      }

      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        SrvVSchema parsedMessage = null;
        try {
          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          parsedMessage = (SrvVSchema) e.getUnfinishedMessage();
          throw e.unwrapIOException();
        } finally {
          if (parsedMessage != null) {
            mergeFrom(parsedMessage);
          }
        }
        return this;
      }
      private int bitField0_;

      private com.google.protobuf.MapField<
          String, Keyspace> keyspaces_;
      private com.google.protobuf.MapField<String, Keyspace>
      internalGetKeyspaces() {
        if (keyspaces_ == null) {
          return com.google.protobuf.MapField.emptyMapField(
              KeyspacesDefaultEntryHolder.defaultEntry);
        }
        return keyspaces_;
      }
      private com.google.protobuf.MapField<String, Keyspace>
      internalGetMutableKeyspaces() {
        onChanged();;
        if (keyspaces_ == null) {
          keyspaces_ = com.google.protobuf.MapField.newMapField(
              KeyspacesDefaultEntryHolder.defaultEntry);
        }
        if (!keyspaces_.isMutable()) {
          keyspaces_ = keyspaces_.copy();
        }
        return keyspaces_;
      }

      public int getKeyspacesCount() {
        return internalGetKeyspaces().getMap().size();
      }
      /**
       * <pre>
       * keyspaces is a map of keyspace name -&gt; Keyspace object.
       * </pre>
       *
       * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
       */

      public boolean containsKeyspaces(
          String key) {
        if (key == null) { throw new NullPointerException(); }
        return internalGetKeyspaces().getMap().containsKey(key);
      }
      /**
       * Use {@link #getKeyspacesMap()} instead.
       */
      @Deprecated
      public java.util.Map<String, Keyspace> getKeyspaces() {
        return getKeyspacesMap();
      }
      /**
       * <pre>
       * keyspaces is a map of keyspace name -&gt; Keyspace object.
       * </pre>
       *
       * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
       */

      public java.util.Map<String, Keyspace> getKeyspacesMap() {
        return internalGetKeyspaces().getMap();
      }
      /**
       * <pre>
       * keyspaces is a map of keyspace name -&gt; Keyspace object.
       * </pre>
       *
       * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
       */

      public Keyspace getKeyspacesOrDefault(
          String key,
          Keyspace defaultValue) {
        if (key == null) { throw new NullPointerException(); }
        java.util.Map<String, Keyspace> map =
            internalGetKeyspaces().getMap();
        return map.containsKey(key) ? map.get(key) : defaultValue;
      }
      /**
       * <pre>
       * keyspaces is a map of keyspace name -&gt; Keyspace object.
       * </pre>
       *
       * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
       */

      public Keyspace getKeyspacesOrThrow(
          String key) {
        if (key == null) { throw new NullPointerException(); }
        java.util.Map<String, Keyspace> map =
            internalGetKeyspaces().getMap();
        if (!map.containsKey(key)) {
          throw new IllegalArgumentException();
        }
        return map.get(key);
      }

      public Builder clearKeyspaces() {
        internalGetMutableKeyspaces().getMutableMap()
            .clear();
        return this;
      }
      /**
       * <pre>
       * keyspaces is a map of keyspace name -&gt; Keyspace object.
       * </pre>
       *
       * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
       */

      public Builder removeKeyspaces(
          String key) {
        if (key == null) { throw new NullPointerException(); }
        internalGetMutableKeyspaces().getMutableMap()
            .remove(key);
        return this;
      }
      /**
       * Use alternate mutation accessors instead.
       */
      @Deprecated
      public java.util.Map<String, Keyspace>
      getMutableKeyspaces() {
        return internalGetMutableKeyspaces().getMutableMap();
      }
      /**
       * <pre>
       * keyspaces is a map of keyspace name -&gt; Keyspace object.
       * </pre>
       *
       * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
       */
      public Builder putKeyspaces(
          String key,
          Keyspace value) {
        if (key == null) { throw new NullPointerException(); }
        if (value == null) { throw new NullPointerException(); }
        internalGetMutableKeyspaces().getMutableMap()
            .put(key, value);
        return this;
      }
      /**
       * <pre>
       * keyspaces is a map of keyspace name -&gt; Keyspace object.
       * </pre>
       *
       * <code>map&lt;string, .vschema.Keyspace&gt; keyspaces = 1;</code>
       */

      public Builder putAllKeyspaces(
          java.util.Map<String, Keyspace> values) {
        internalGetMutableKeyspaces().getMutableMap()
            .putAll(values);
        return this;
      }

      private RoutingRules routingRules_ = null;
      private com.google.protobuf.SingleFieldBuilderV3<
          RoutingRules, RoutingRules.Builder, RoutingRulesOrBuilder> routingRulesBuilder_;
      /**
       * <code>.vschema.RoutingRules routing_rules = 2;</code>
       */
      public boolean hasRoutingRules() {
        return routingRulesBuilder_ != null || routingRules_ != null;
      }
      /**
       * <code>.vschema.RoutingRules routing_rules = 2;</code>
       */
      public RoutingRules getRoutingRules() {
        if (routingRulesBuilder_ == null) {
          return routingRules_ == null ? RoutingRules.getDefaultInstance() : routingRules_;
        } else {
          return routingRulesBuilder_.getMessage();
        }
      }
      /**
       * <code>.vschema.RoutingRules routing_rules = 2;</code>
       */
      public Builder setRoutingRules(RoutingRules value) {
        if (routingRulesBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          routingRules_ = value;
          onChanged();
        } else {
          routingRulesBuilder_.setMessage(value);
        }

        return this;
      }
      /**
       * <code>.vschema.RoutingRules routing_rules = 2;</code>
       */
      public Builder setRoutingRules(
          RoutingRules.Builder builderForValue) {
        if (routingRulesBuilder_ == null) {
          routingRules_ = builderForValue.build();
          onChanged();
        } else {
          routingRulesBuilder_.setMessage(builderForValue.build());
        }

        return this;
      }
      /**
       * <code>.vschema.RoutingRules routing_rules = 2;</code>
       */
      public Builder mergeRoutingRules(RoutingRules value) {
        if (routingRulesBuilder_ == null) {
          if (routingRules_ != null) {
            routingRules_ =
              RoutingRules.newBuilder(routingRules_).mergeFrom(value).buildPartial();
          } else {
            routingRules_ = value;
          }
          onChanged();
        } else {
          routingRulesBuilder_.mergeFrom(value);
        }

        return this;
      }
      /**
       * <code>.vschema.RoutingRules routing_rules = 2;</code>
       */
      public Builder clearRoutingRules() {
        if (routingRulesBuilder_ == null) {
          routingRules_ = null;
          onChanged();
        } else {
          routingRules_ = null;
          routingRulesBuilder_ = null;
        }

        return this;
      }
      /**
       * <code>.vschema.RoutingRules routing_rules = 2;</code>
       */
      public RoutingRules.Builder getRoutingRulesBuilder() {
        
        onChanged();
        return getRoutingRulesFieldBuilder().getBuilder();
      }
      /**
       * <code>.vschema.RoutingRules routing_rules = 2;</code>
       */
      public RoutingRulesOrBuilder getRoutingRulesOrBuilder() {
        if (routingRulesBuilder_ != null) {
          return routingRulesBuilder_.getMessageOrBuilder();
        } else {
          return routingRules_ == null ?
              RoutingRules.getDefaultInstance() : routingRules_;
        }
      }
      /**
       * <code>.vschema.RoutingRules routing_rules = 2;</code>
       */
      private com.google.protobuf.SingleFieldBuilderV3<
          RoutingRules, RoutingRules.Builder, RoutingRulesOrBuilder>
          getRoutingRulesFieldBuilder() {
        if (routingRulesBuilder_ == null) {
          routingRulesBuilder_ = new com.google.protobuf.SingleFieldBuilderV3<
              RoutingRules, RoutingRules.Builder, RoutingRulesOrBuilder>(
                  getRoutingRules(),
                  getParentForChildren(),
                  isClean());
          routingRules_ = null;
        }
        return routingRulesBuilder_;
      }
      public final Builder setUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.setUnknownFieldsProto3(unknownFields);
      }

      public final Builder mergeUnknownFields(
          final com.google.protobuf.UnknownFieldSet unknownFields) {
        return super.mergeUnknownFields(unknownFields);
      }


      // @@protoc_insertion_point(builder_scope:vschema.SrvVSchema)
    }

    // @@protoc_insertion_point(class_scope:vschema.SrvVSchema)
    private static final SrvVSchema DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new SrvVSchema();
    }

    public static SrvVSchema getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<SrvVSchema>
        PARSER = new com.google.protobuf.AbstractParser<SrvVSchema>() {
      public SrvVSchema parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        return new SrvVSchema(input, extensionRegistry);
      }
    };

    public static com.google.protobuf.Parser<SrvVSchema> parser() {
      return PARSER;
    }

    @Override
    public com.google.protobuf.Parser<SrvVSchema> getParserForType() {
      return PARSER;
    }

    public SrvVSchema getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_vschema_RoutingRules_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_vschema_RoutingRules_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_vschema_RoutingRule_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_vschema_RoutingRule_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_vschema_Keyspace_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_vschema_Keyspace_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_vschema_Keyspace_VindexesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_vschema_Keyspace_VindexesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_vschema_Keyspace_TablesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_vschema_Keyspace_TablesEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_vschema_Vindex_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_vschema_Vindex_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_vschema_Vindex_ParamsEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_vschema_Vindex_ParamsEntry_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_vschema_Table_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_vschema_Table_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_vschema_ColumnVindex_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_vschema_ColumnVindex_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_vschema_AutoIncrement_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_vschema_AutoIncrement_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_vschema_Column_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_vschema_Column_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_vschema_SrvVSchema_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_vschema_SrvVSchema_fieldAccessorTable;
  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_vschema_SrvVSchema_KeyspacesEntry_descriptor;
  private static final 
    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internal_static_vschema_SrvVSchema_KeyspacesEntry_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    String[] descriptorData = {
      "\n\rvschema.proto\022\007vschema\032\013query.proto\"3\n" +
      "\014RoutingRules\022#\n\005rules\030\001 \003(\0132\024.vschema.R" +
      "outingRule\"4\n\013RoutingRule\022\022\n\nfrom_table\030" +
      "\001 \001(\t\022\021\n\tto_tables\030\002 \003(\t\"\240\002\n\010Keyspace\022\017\n" +
      "\007sharded\030\001 \001(\010\0221\n\010vindexes\030\002 \003(\0132\037.vsche" +
      "ma.Keyspace.VindexesEntry\022-\n\006tables\030\003 \003(" +
      "\0132\035.vschema.Keyspace.TablesEntry\022 \n\030requ" +
      "ire_explicit_routing\030\004 \001(\010\032@\n\rVindexesEn" +
      "try\022\013\n\003key\030\001 \001(\t\022\036\n\005value\030\002 \001(\0132\017.vschem" +
      "a.Vindex:\0028\001\032=\n\013TablesEntry\022\013\n\003key\030\001 \001(\t" +
      "\022\035\n\005value\030\002 \001(\0132\016.vschema.Table:\0028\001\"\201\001\n\006" +
      "Vindex\022\014\n\004type\030\001 \001(\t\022+\n\006params\030\002 \003(\0132\033.v" +
      "schema.Vindex.ParamsEntry\022\r\n\005owner\030\003 \001(\t" +
      "\032-\n\013ParamsEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 " +
      "\001(\t:\0028\001\"\312\001\n\005Table\022\014\n\004type\030\001 \001(\t\022.\n\017colum" +
      "n_vindexes\030\002 \003(\0132\025.vschema.ColumnVindex\022" +
      ".\n\016auto_increment\030\003 \001(\0132\026.vschema.AutoIn" +
      "crement\022 \n\007columns\030\004 \003(\0132\017.vschema.Colum" +
      "n\022\016\n\006pinned\030\005 \001(\t\022!\n\031column_list_authori" +
      "tative\030\006 \001(\010\"=\n\014ColumnVindex\022\016\n\006column\030\001" +
      " \001(\t\022\014\n\004name\030\002 \001(\t\022\017\n\007columns\030\003 \003(\t\"1\n\rA" +
      "utoIncrement\022\016\n\006column\030\001 \001(\t\022\020\n\010sequence" +
      "\030\002 \001(\t\"1\n\006Column\022\014\n\004name\030\001 \001(\t\022\031\n\004type\030\002" +
      " \001(\0162\013.query.Type\"\266\001\n\nSrvVSchema\0225\n\tkeys" +
      "paces\030\001 \003(\0132\".vschema.SrvVSchema.Keyspac" +
      "esEntry\022,\n\rrouting_rules\030\002 \001(\0132\025.vschema" +
      ".RoutingRules\032C\n\016KeyspacesEntry\022\013\n\003key\030\001" +
      " \001(\t\022 \n\005value\030\002 \001(\0132\021.vschema.Keyspace:\002" +
      "8\001B&Z$vitess.io/vitess/go/vt/proto/vsche" +
      "mab\006proto3"
    };
    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =
        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {
          public com.google.protobuf.ExtensionRegistry assignDescriptors(
              com.google.protobuf.Descriptors.FileDescriptor root) {
            descriptor = root;
            return null;
          }
        };
    com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          io.vitess.proto.Query.getDescriptor(),
        }, assigner);
    internal_static_vschema_RoutingRules_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_vschema_RoutingRules_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_vschema_RoutingRules_descriptor,
        new String[] { "Rules", });
    internal_static_vschema_RoutingRule_descriptor =
      getDescriptor().getMessageTypes().get(1);
    internal_static_vschema_RoutingRule_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_vschema_RoutingRule_descriptor,
        new String[] { "FromTable", "ToTables", });
    internal_static_vschema_Keyspace_descriptor =
      getDescriptor().getMessageTypes().get(2);
    internal_static_vschema_Keyspace_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_vschema_Keyspace_descriptor,
        new String[] { "Sharded", "Vindexes", "Tables", "RequireExplicitRouting", });
    internal_static_vschema_Keyspace_VindexesEntry_descriptor =
      internal_static_vschema_Keyspace_descriptor.getNestedTypes().get(0);
    internal_static_vschema_Keyspace_VindexesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_vschema_Keyspace_VindexesEntry_descriptor,
        new String[] { "Key", "Value", });
    internal_static_vschema_Keyspace_TablesEntry_descriptor =
      internal_static_vschema_Keyspace_descriptor.getNestedTypes().get(1);
    internal_static_vschema_Keyspace_TablesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_vschema_Keyspace_TablesEntry_descriptor,
        new String[] { "Key", "Value", });
    internal_static_vschema_Vindex_descriptor =
      getDescriptor().getMessageTypes().get(3);
    internal_static_vschema_Vindex_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_vschema_Vindex_descriptor,
        new String[] { "Type", "Params", "Owner", });
    internal_static_vschema_Vindex_ParamsEntry_descriptor =
      internal_static_vschema_Vindex_descriptor.getNestedTypes().get(0);
    internal_static_vschema_Vindex_ParamsEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_vschema_Vindex_ParamsEntry_descriptor,
        new String[] { "Key", "Value", });
    internal_static_vschema_Table_descriptor =
      getDescriptor().getMessageTypes().get(4);
    internal_static_vschema_Table_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_vschema_Table_descriptor,
        new String[] { "Type", "ColumnVindexes", "AutoIncrement", "Columns", "Pinned", "ColumnListAuthoritative", });
    internal_static_vschema_ColumnVindex_descriptor =
      getDescriptor().getMessageTypes().get(5);
    internal_static_vschema_ColumnVindex_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_vschema_ColumnVindex_descriptor,
        new String[] { "Column", "Name", "Columns", });
    internal_static_vschema_AutoIncrement_descriptor =
      getDescriptor().getMessageTypes().get(6);
    internal_static_vschema_AutoIncrement_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_vschema_AutoIncrement_descriptor,
        new String[] { "Column", "Sequence", });
    internal_static_vschema_Column_descriptor =
      getDescriptor().getMessageTypes().get(7);
    internal_static_vschema_Column_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_vschema_Column_descriptor,
        new String[] { "Name", "Type", });
    internal_static_vschema_SrvVSchema_descriptor =
      getDescriptor().getMessageTypes().get(8);
    internal_static_vschema_SrvVSchema_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_vschema_SrvVSchema_descriptor,
        new String[] { "Keyspaces", "RoutingRules", });
    internal_static_vschema_SrvVSchema_KeyspacesEntry_descriptor =
      internal_static_vschema_SrvVSchema_descriptor.getNestedTypes().get(0);
    internal_static_vschema_SrvVSchema_KeyspacesEntry_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(
        internal_static_vschema_SrvVSchema_KeyspacesEntry_descriptor,
        new String[] { "Key", "Value", });
    io.vitess.proto.Query.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
